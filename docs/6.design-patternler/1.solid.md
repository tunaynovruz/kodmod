---
title: SOLID Prinsipləri
description: SOLID prinsiplərinin Java-da tətbiqi və izahı
slug: solid
tags: [java, solid, design-principles, clean-code, oop]
keywords: [solid principles, java, single responsibility, open closed, liskov substitution, interface segregation, dependency inversion]
hide_table_of_contents: false
sidebar_label: SOLID Prinsipləri
---

# SOLID Prinsipləri

SOLID - obyekt yönümlü proqramlaşdırma üçün 5 əsas prinsipdir. Bu prinsiplər kodu daha oxunaqlı, genişləndirilə bilən və saxlanıla bilən edir.

## S - Single Responsibility Principle (SRP)

Hər bir class yalnız bir səbəbə görə dəyişməlidir.

### Səhv nümunə:
```java
// Bu class həm user məlumatlarını saxlayır, həm də email göndərir
class User {
    private String name;
    private String email;
    
    public void saveUser() {
        // Database-ə user yadda saxla
    }
    
    public void sendEmail() {
        // Email göndər
    }
}
```

### Düzgün nümunə:
```java
// User məlumatları üçün
class User {
    private String name;
    private String email;
    
    // getters və setters
}

// Database əməliyyatları üçün
class UserRepository {
    public void saveUser(User user) {
        // Database-ə user yadda saxla
    }
}

// Email xidməti üçün
class EmailService {
    public void sendEmail(String email, String message) {
        // Email göndər
    }
}
```

## O - Open/Closed Principle (OCP)

Class-lar genişləndirmə üçün açıq, dəyişiklik üçün bağlı olmalıdır.

### Düzgün nümunə:
```java
// Abstract base class
abstract class Shape {
    public abstract double calculateArea();
}

// Konkret implementasiyalar
class Rectangle extends Shape {
    private double width, height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return width * height;
    }
}

class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}

// Yeni shape əlavə etmək üçün mövcud kodu dəyişməyə ehtiyac yoxdur
class Triangle extends Shape {
    private double base, height;
    
    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double calculateArea() {
        return (base * height) / 2;
    }
}
```

## L - Liskov Substitution Principle (LSP)

Alt class-ların obyektləri ana class-ın obyektlərini əvəz edə bilməlidir.

### Düzgün nümunə:
```java
class Bird {
    public void eat() {
        System.out.println("Quş yemək yeyir");
    }
}

class FlyingBird extends Bird {
    public void fly() {
        System.out.println("Quş uçur");
    }
}

class Sparrow extends FlyingBird {
    @Override
    public void fly() {
        System.out.println("Sərçə sürətlə uçur");
    }
}

class Penguin extends Bird {
    // Penguin uçmur, ona görə FlyingBird-dən inherit etmir
    public void swim() {
        System.out.println("Pingvin üzür");
    }
}
```

## I - Interface Segregation Principle (ISP)

Client-lər istifadə etmədikləri interface-lərə asılı olmamalıdır.

### Səhv nümunə:
```java
// Böyük interface
interface Worker {
    void work();
    void eat();
    void sleep();
}
```

### Düzgün nümunə:
```java
// Kiçik, məqsədli interface-lər
interface Workable {
    void work();
}

interface Feedable {
    void eat();
}

interface Sleepable {
    void sleep();
}

// Human həm işləyir, həm yeyir, həm də yatır
class Human implements Workable, Feedable, Sleepable {
    public void work() { System.out.println("İnsan işləyir"); }
    public void eat() { System.out.println("İnsan yeyir"); }
    public void sleep() { System.out.println("İnsan yatır"); }
}

// Robot yalnız işləyir
class Robot implements Workable {
    public void work() { System.out.println("Robot işləyir"); }
}
```

## D - Dependency Inversion Principle (DIP)

Yüksək səviyyəli modullər aşağı səviyyəli modullara asılı olmamalıdır. Hər ikisi abstraksiyalara asılı olmalıdır.

### Səhv nümunə:
```java
class MySQLDatabase {
    public void save(String data) {
        // MySQL-ə yadda saxla
    }
}

class UserService {
    private MySQLDatabase database = new MySQLDatabase(); // Birbaşa asılılıq
    
    public void saveUser(String userData) {
        database.save(userData);
    }
}
```

### Düzgün nümunə:
```java
// Interface abstraksiya
interface Database {
    void save(String data);
}

// Konkret implementasiya
class MySQLDatabase implements Database {
    public void save(String data) {
        System.out.println("MySQL-ə yadda saxlanıldı: " + data);
    }
}

class PostgreSQLDatabase implements Database {
    public void save(String data) {
        System.out.println("PostgreSQL-ə yadda saxlanıldı: " + data);
    }
}

// Service abstraksiyaya asılıdır
class UserService {
    private Database database;
    
    public UserService(Database database) {
        this.database = database;
    }
    
    public void saveUser(String userData) {
        database.save(userData);
    }
}

// İstifadə
Database db = new MySQLDatabase();
UserService service = new UserService(db);
service.saveUser("User data");
```

## Nəticə

SOLID prinsipləri:
- Kodun oxunaqlığını artırır
- Genişləndirmə imkanlarını yaxşılaşdırır  
- Test yazma prosesini asanlaşdırır
- Bug-ların sayını azaldır
- Kod yenidən istifadə olunmasını təmin edir