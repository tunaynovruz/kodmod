---
title: Memento Pattern
description: Memento design pattern-nin ətraflı izahı və Java-da implementasiyası
slug: memento-pattern
tags: [design-patterns, behavioral, memento, java]
keywords: [memento pattern, design pattern, behavioral pattern, java]
hide_table_of_contents: false
---

# Memento Design Pattern

Obyektin daxili vəziyyətini saxlamağa və sonradan bərpa etməyə imkan verir. Bu pattern, obyektin encapsulation-ını pozmadan onun əvvəlki vəziyyətinə qayıtmaq üçün istifadə edilir.

Memento pattern, real həyatda "undo" funksiyasına bənzəyir. Məsələn, mətn editorlarında yazdığınız mətni silsəniz, "Ctrl+Z" ilə əvvəlki vəziyyətinə qayıda bilərsiniz.

## Memento Pattern-nin Əsas Xüsusiyyətləri

- **State Preservation**: Obyektin vəziyyətini saxlayır
- **Rollback Capability**: Əvvəlki vəziyyətə qayıtmaq imkanı
- **Encapsulation Protection**: Obyektin daxili strukturunu pozmaır
- **History Management**: Vəziyyət tarixini idarə edir

## Memento Pattern-nin Strukturu

1. **Originator**: Vəziyyəti olan və memento yaradan obyekt
2. **Memento**: Originator-ın vəziyyətini saxlayan obyekt
3. **Caretaker**: Memento-ları saxlayan və idarə edən obyekt

## Java-da Memento Pattern İmplementasiyası

### Sadə Memento Pattern Nümunəsi

<details>
<summary>Koda bax</summary>

```java
// Memento class
class TextMemento {
    private final String text;
    private final int cursorPosition;
    
    public TextMemento(String text, int cursorPosition) {
        this.text = text;
        this.cursorPosition = cursorPosition;
    }
    
    public String getText() {
        return text;
    }
    
    public int getCursorPosition() {
        return cursorPosition;
    }
}

// Originator class
class TextEditor {
    private String text;
    private int cursorPosition;
    
    public TextEditor() {
        this.text = "";
        this.cursorPosition = 0;
    }
    
    public void setText(String text) {
        this.text = text;
        this.cursorPosition = text.length();
    }
    
    public void addText(String newText) {
        this.text += newText;
        this.cursorPosition = this.text.length();
    }
    
    public String getText() {
        return text;
    }
    
    public int getCursorPosition() {
        return cursorPosition;
    }
    
    // Create memento
    public TextMemento createMemento() {
        return new TextMemento(text, cursorPosition);
    }
    
    // Restore from memento
    public void restoreFromMemento(TextMemento memento) {
        this.text = memento.getText();
        this.cursorPosition = memento.getCursorPosition();
    }
    
    public void displayStatus() {
        System.out.println("Text: '" + text + "', Cursor: " + cursorPosition);
    }
}

// Caretaker class
class EditorHistory {
    private java.util.Stack<TextMemento> history = new java.util.Stack<>();
    
    public void save(TextEditor editor) {
        history.push(editor.createMemento());
        System.out.println("State saved to history");
    }
    
    public void undo(TextEditor editor) {
        if (!history.isEmpty()) {
            TextMemento memento = history.pop();
            editor.restoreFromMemento(memento);
            System.out.println("State restored from history");
        } else {
            System.out.println("No more states to restore");
        }
    }
    
    public int getHistorySize() {
        return history.size();
    }
}

// Client code
public class MementoPatternDemo {
    public static void main(String[] args) {
        TextEditor editor = new TextEditor();
        EditorHistory history = new EditorHistory();
        
        // Initial state
        editor.setText("Hello");
        editor.displayStatus();
        
        // Save state
        history.save(editor);
        
        // Modify text
        editor.addText(" World");
        editor.displayStatus();
        
        // Save state again
        history.save(editor);
        
        // Modify text more
        editor.addText("!!!");
        editor.displayStatus();
        
        // Undo last change
        System.out.println("\nPerforming undo...");
        history.undo(editor);
        editor.displayStatus();
        
        // Undo one more time
        System.out.println("\nPerforming undo again...");
        history.undo(editor);
        editor.displayStatus();
        
        // Try to undo when no history
        System.out.println("\nTrying to undo with no history...");
        history.undo(editor);
    }
}
```

</details>

### Çıxış:
```
Text: 'Hello', Cursor: 5
State saved to history
Text: 'Hello World', Cursor: 11
State saved to history
Text: 'Hello World!!!', Cursor: 14

Performing undo...
State restored from history
Text: 'Hello World', Cursor: 11

Performing undo again...
State restored from history
Text: 'Hello', Cursor: 5

Trying to undo with no history...
No more states to restore
```

## Memento Pattern-nin Üstünlükləri

- **Encapsulation Qorunması**: Obyektin daxili strukturu pozulmur
- **Undo/Redo Dəstəyi**: Sadə undo/redo funksionallığı təmin edir
- **State Management**: Vəziyyət idarəsini sadələşdirir
- **Flexibility**: Müxtəlif vəziyyətləri saxlamaq mümkündür

## Memento Pattern-nin Çatışmazlıqları

- **Memory Usage**: Çox sayda memento saxlamaq yaddaş problemi yarada bilər
- **Performance**: Böyük obyektlərin kopyalanması performans problemlərinə səbəb ola bilər
- **Complexity**: Mürəkkəb obyektlər üçün implementasiya çətin ola bilər

## İstifadə Halları

- **Text Editors**: Mətn editorlarında undo/redo funksiyası
- **Games**: Oyunlarda checkpoint və save/load sistemləri
- **Database Transactions**: Verilənlər bazasında rollback əməliyyatları
- **Configuration Management**: Konfiqurasiya dəyişikliklərinin idarə edilməsi

## Memento vs Command Pattern

- **Memento**: Obyektin vəziyyətini saxlayır
- **Command**: Əməliyyatları saxlayır və undo etmək üçün əks əməliyyat yerinə yetirir

Memento Pattern, vəziyyət idarəsi tələb olunan hallarda çox faydalı bir pattern-dir və xüsusilə undo/redo funksionallığı tələb olunan aplikasiyalarda geniş istifadə olunur.