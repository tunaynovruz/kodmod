---
title: Mediator Pattern
description: Mediator design pattern-nin ətraflı izahı və Java-da implementasiyası
slug: mediator-pattern
tags: [design-patterns, behavioral, mediator, java]
keywords: [mediator pattern, design pattern, behavioral pattern, java]
hide_table_of_contents: false
---

# Mediator Design Pattern

Obyektlər arasında qarşılıqlı əlaqəni azaltmağa kömək edir. Bu pattern, obyektlərin bir-biri ilə birbaşa əlaqə saxlamaq əvəzinə, mediator vasitəsilə ünsiyyət qurmasını təmin edir.

Mediator pattern, real həyatda havayolu trafik nəzarət mərkəzinə bənzəyir. Təyyarələr bir-biri ilə birbaşa danışmaq əvəzinə, hava trafik nəzarətçisi ilə əlaqə saxlayırlar və o onların hərəkətini koordinasiya edir.

## Mediator Pattern-nin Əsas Xüsusiyyətləri

- **Loose Coupling**: Obyektlər arasında zəif əlaqə yaradır
- **Centralized Communication**: Mərkəzləşdirilmiş ünsiyyət
- **Simplified Relations**: Çoxluq-çoxluq əlaqəni çoxluq-bir əlaqəyə çevirir
- **Reusability**: Mediator təkrar istifadə edilə bilər

## Mediator Pattern-nin Strukturu

1. **Mediator**: Kollega obyektlər arasında ünsiyyət üçün interface
2. **ConcreteMediator**: Mediator interface-ni implement edən class
3. **Colleague**: Mediator-la ünsiyyət quran obyektlər üçün əsas class
4. **ConcreteColleague**: Konkret kollega obyektləri

## Java-da Mediator Pattern İmplementasiyası

### Chat Room Nümunəsi

<details>
<summary>Koda bax</summary>

```java
// Mediator interface
interface ChatMediator {
    void sendMessage(String message, User user);
    void addUser(User user);
}

// Concrete Mediator
class ChatRoom implements ChatMediator {
    private java.util.List<User> users = new java.util.ArrayList<>();
    
    @Override
    public void addUser(User user) {
        users.add(user);
        System.out.println(user.getName() + " joined the chat room.");
    }
    
    @Override
    public void sendMessage(String message, User user) {
        System.out.println(user.getName() + " sends: " + message);
        
        // Send message to all other users
        for (User u : users) {
            if (u != user) {
                u.receive(message, user.getName());
            }
        }
    }
}

// Colleague abstract class
abstract class User {
    protected ChatMediator mediator;
    protected String name;
    
    public User(ChatMediator mediator, String name) {
        this.mediator = mediator;
        this.name = name;
    }
    
    public abstract void send(String message);
    public abstract void receive(String message, String from);
    
    public String getName() {
        return name;
    }
}

// Concrete Colleagues
class RegularUser extends User {
    public RegularUser(ChatMediator mediator, String name) {
        super(mediator, name);
    }
    
    @Override
    public void send(String message) {
        mediator.sendMessage(message, this);
    }
    
    @Override
    public void receive(String message, String from) {
        System.out.println(name + " received: " + message + " from " + from);
    }
}

class AdminUser extends User {
    public AdminUser(ChatMediator mediator, String name) {
        super(mediator, name);
    }
    
    @Override
    public void send(String message) {
        System.out.println("[ADMIN MESSAGE]");
        mediator.sendMessage(message, this);
    }
    
    @Override
    public void receive(String message, String from) {
        System.out.println("[ADMIN] " + name + " received: " + message + " from " + from);
    }
}

// Client code
public class MediatorPatternDemo {
    public static void main(String[] args) {
        ChatMediator chatRoom = new ChatRoom();
        
        User user1 = new RegularUser(chatRoom, "Alice");
        User user2 = new RegularUser(chatRoom, "Bob");
        User user3 = new AdminUser(chatRoom, "Charlie");
        
        chatRoom.addUser(user1);
        chatRoom.addUser(user2);
        chatRoom.addUser(user3);
        
        System.out.println();
        
        user1.send("Hello everyone!");
        System.out.println();
        
        user2.send("Hi Alice!");
        System.out.println();
        
        user3.send("Welcome to the chat room!");
    }
}
```

</details>

### Çıxış:
```
Alice joined the chat room.
Bob joined the chat room.
Charlie joined the chat room.

Alice sends: Hello everyone!
Bob received: Hello everyone! from Alice
[ADMIN] Charlie received: Hello everyone! from Alice

Bob sends: Hi Alice!
Alice received: Hi Alice! from Bob
[ADMIN] Charlie received: Hi Alice! from Bob

[ADMIN MESSAGE]
Charlie sends: Welcome to the chat room!
Alice received: Welcome to the chat room! from Charlie
Bob received: Welcome to the chat room! from Charlie
```

### Air Traffic Control Nümunəsi

<details>
<summary>Koda bax</summary>

```java
// Air Traffic Control Mediator
interface AirTrafficControl {
    void requestLanding(Aircraft aircraft);
    void requestTakeoff(Aircraft aircraft);
    void registerAircraft(Aircraft aircraft);
}

// Concrete Mediator
class ControlTower implements AirTrafficControl {
    private java.util.List<Aircraft> aircrafts = new java.util.ArrayList<>();
    private boolean runwayAvailable = true;
    
    @Override
    public void registerAircraft(Aircraft aircraft) {
        aircrafts.add(aircraft);
        System.out.println(aircraft.getName() + " registered with control tower.");
    }
    
    @Override
    public void requestLanding(Aircraft aircraft) {
        if (runwayAvailable) {
            runwayAvailable = false;
            System.out.println("Control Tower: " + aircraft.getName() + " cleared for landing.");
            aircraft.land();
        } else {
            System.out.println("Control Tower: " + aircraft.getName() + " hold position, runway busy.");
        }
    }
    
    @Override
    public void requestTakeoff(Aircraft aircraft) {
        if (runwayAvailable) {
            runwayAvailable = false;
            System.out.println("Control Tower: " + aircraft.getName() + " cleared for takeoff.");
            aircraft.takeoff();
        } else {
            System.out.println("Control Tower: " + aircraft.getName() + " hold position, runway busy.");
        }
    }
    
    public void runwayCleared() {
        runwayAvailable = true;
        System.out.println("Control Tower: Runway is now available.");
    }
}

// Colleague class
abstract class Aircraft {
    protected AirTrafficControl atc;
    protected String name;
    
    public Aircraft(AirTrafficControl atc, String name) {
        this.atc = atc;
        this.name = name;
    }
    
    public abstract void requestLanding();
    public abstract void requestTakeoff();
    public abstract void land();
    public abstract void takeoff();
    
    public String getName() {
        return name;
    }
}

// Concrete Colleagues
class CommercialAircraft extends Aircraft {
    public CommercialAircraft(AirTrafficControl atc, String name) {
        super(atc, name);
    }
    
    @Override
    public void requestLanding() {
        System.out.println(name + ": Requesting permission to land.");
        atc.requestLanding(this);
    }
    
    @Override
    public void requestTakeoff() {
        System.out.println(name + ": Requesting permission to takeoff.");
        atc.requestTakeoff(this);
    }
    
    @Override
    public void land() {
        System.out.println(name + ": Landing completed.");
        // Simulate runway clearance after landing
        if (atc instanceof ControlTower) {
            ((ControlTower) atc).runwayCleared();
        }
    }
    
    @Override
    public void takeoff() {
        System.out.println(name + ": Takeoff completed.");
        // Simulate runway clearance after takeoff
        if (atc instanceof ControlTower) {
            ((ControlTower) atc).runwayCleared();
        }
    }
}

class PrivateJet extends Aircraft {
    public PrivateJet(AirTrafficControl atc, String name) {
        super(atc, name);
    }
    
    @Override
    public void requestLanding() {
        System.out.println(name + " (Private Jet): Requesting priority landing.");
        atc.requestLanding(this);
    }
    
    @Override
    public void requestTakeoff() {
        System.out.println(name + " (Private Jet): Requesting priority takeoff.");
        atc.requestTakeoff(this);
    }
    
    @Override
    public void land() {
        System.out.println(name + " (Private Jet): Quick landing completed.");
        if (atc instanceof ControlTower) {
            ((ControlTower) atc).runwayCleared();
        }
    }
    
    @Override
    public void takeoff() {
        System.out.println(name + " (Private Jet): Quick takeoff completed.");
        if (atc instanceof ControlTower) {
            ((ControlTower) atc).runwayCleared();
        }
    }
}
```

</details>

## Mediator Pattern-nin Üstünlükləri

- **Reduced Coupling**: Obyektlər arasında asılılığı azaldır
- **Centralized Control**: Mürəkkəb ünsiyyət məntiqini mərkəzləşdirir
- **Reusability**: Fərqli kontekstlərdə təkrar istifadə edilə bilər
- **Easy Maintenance**: Ünsiyyət məntiqini dəyişmək asanlaşır

## Mediator Pattern-nin Çatışmazlıqları

- **God Object**: Mediator çox mürəkkəb ola bilər
- **Single Point of Failure**: Mediator çökərsə, bütün ünsiyyət dayanır
- **Performance**: Əlavə abstraction layer performansı təsir edə bilər

## İstifadə Halları

- **GUI Applications**: UI komponentləri arasında ünsiyyət
- **Chat Applications**: İstifadəçilər arasında mesaj mübadiləsi
- **Workflow Systems**: Müxtəlif addımlar arasında koordinasiya
- **Game Development**: Oyun obyektləri arasında qarşılıqlı təsir

## Mediator vs Observer Pattern

- **Mediator**: Obyektlər arasında iki tərəfli ünsiyyəti təmin edir
- **Observer**: Bir obyektdən çoxuna doğru birtərəfli bildiriş göndərir

## Mediator vs Facade Pattern

- **Mediator**: Kollega obyektləri mediator-dan xəbərdardır
- **Facade**: Alt sistem obyektləri facade-dan xəbərsizdir

Mediator Pattern, mürəkkəb obyekt şəbəkələrində ünsiyyəti təşkil etmək üçün çox faydalı bir pattern-dir və xüsusilə çoxlu obyektin qarşılıqlı əlaqədə olduğu sistemlərdə geniş istifadə olunur.