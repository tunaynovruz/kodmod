---
sidebar_label: Integration Testing
---
# Integration Testing

Integration testing verifies that different components work together correctly.

## Types of Integration Testing

- **Top-Down**: Testing starts with top-level modules
- **Bottom-Up**: Testing starts with lower-level modules  
- **Big Bang**: All components integrated simultaneously
- **Hybrid**: Combines top-down and bottom-up approaches

## Integration Testing vs. Unit Testing

| Integration Testing | Unit Testing |
|---------------------|--------------|
| Tests interactions between components | Tests individual components in isolation |
| Identifies interface issues | Verifies component functionality |
| Slower execution | Fast execution |
| Requires more setup | Minimal setup with mocks/stubs |
| Tests real dependencies | Uses test doubles for dependencies |

## Java Tools

- Spring Test: Testing Spring applications
- REST-assured: Testing RESTful APIs
- Testcontainers: Lightweight database/service instances
- Arquillian: Testing Java EE applications

## Integration Testing Best Practices

1. **Define clear boundaries**: Determine what components to include in each test
2. **Use test environments**: Create isolated environments for integration tests
3. **Manage test data**: Ensure test data is consistent and isolated
4. **Control external dependencies**: Use containers or mocks for external services
5. **Focus on interfaces**: Test the contracts between components
6. **Automate setup and teardown**: Ensure clean state before and after tests
7. **Include in CI/CD pipeline**: Run integration tests as part of continuous integration

## Example: Integration Test for a REST API


<details>
<summary>Koda bax</summary>

```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
public class UserControllerIntegrationTest {

    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private UserRepository userRepository;
    
    @BeforeEach
    void setup() {
        userRepository.deleteAll();
    }
    
    @Test
    void createUser_shouldReturnCreatedUser() {
        // Prepare test data
        UserDto userDto = new UserDto("john", "john@example.com");
        
        // Send request to the API
        ResponseEntity<User> response = restTemplate.postForEntity(
            "/api/users", userDto, User.class);
        
        // Verify response
        assertEquals(HttpStatus.CREATED, response.getStatusCode());
        assertNotNull(response.getBody());
        assertEquals("john", response.getBody().getUsername());
        
        // Verify data was saved to the database
        Optional<User> savedUser = userRepository.findByUsername("john");
        assertTrue(savedUser.isPresent());
    }
}
```
</details>

## Example: Integration Test with Testcontainers


<details>
<summary>Koda bax</summary>

```java
@Testcontainers
public class UserServiceIntegrationTest {

    @Container
    private static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:13")
        .withDatabaseName("testdb")
        .withUsername("test")
        .withPassword("test");
    
    private UserService userService;
    private UserRepository userRepository;
    
    @BeforeEach
    void setup() {
        // Configure datasource with container connection details
        DataSource dataSource = DataSourceBuilder.create()
            .url(postgres.getJdbcUrl())
            .username(postgres.getUsername())
            .password(postgres.getPassword())
            .build();
            
        userRepository = new UserRepositoryImpl(dataSource);
        userService = new UserService(userRepository);
    }
    
    @Test
    void createAndRetrieveUser() {
        // Create a user
        User user = new User("alice", "alice@example.com");
        userService.createUser(user);
        
        // Retrieve and verify
        User retrieved = userService.findByUsername("alice");
        assertNotNull(retrieved);
        assertEquals("alice@example.com", retrieved.getEmail());
    }
}
```
</details>

## When to Use Integration Tests

- Testing interactions between multiple components
- Verifying database operations
- Testing API endpoints
- Validating message processing in event-driven systems
