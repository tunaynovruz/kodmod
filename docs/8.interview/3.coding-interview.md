---
title: Coding Interview
sidebar_label: Coding Interview
sidebar_class_name: green
---

# Coding Interview Hazırlığı

Coding interview texniki bacarıqlarınızı qiymətləndirən ən mühüm mərhələdir. Bu prosesdə alqoritm bilginiz, problem həlli yanaşmanız və kodlaşdırma bacarıqlarınız yoxlanılır.

## Interview Prosesi

### 1. Problem Anlayışı (5 dəqiqə)
- **Problemi diqqətlə oxuyun**
- **Suallar verin**: Məhdudiyyətlər, məlumat strukturu, gözlənilən nəticə
- **Nümunələrlə yoxlayın**: Input/output nümunələrini təhlil edin

```java
// Problem anlama nümunəsi
public class TwoSum {
    /*
    Problem: Verilmiş array-də iki ədədin cəmi target-ə bərabər olan indeksləri tapın
    Input: nums = [2,7,11,15], target = 9
    Output: [0,1] (çünki nums[0] + nums[1] = 2 + 7 = 9)
    
    Suallar:
    - Array-də duplicate dəyərlər varmı?
    - Həmişə həll varmı?
    - Bir nəticə kifayətdirmi?
    */
}
```

### 2. Yanaşma Planlaşdırması (10 dəqiqə)
- **Brute force həllindən başlayın**
- **Optimizasiya imkanlarını düşünün**
- **Time/Space complexity təhlil edin**
- **Pseudo kod yazın**

### 3. Kod Yazma (20 dəqiqə)
- **Sadə və oxunaqlı kod**
- **Dəyişən adlarını mənalı seçin**
- **Edge case-ləri nəzərə alın**

### 4. Test və Debug (10 dəqiqə)
- **Nümunə input-larla yoxlayın**
- **Edge case-ləri test edin**
- **Kod logikasını izah edin**

## Əsas Alqoritm Mövzuları

### 1. Array və String
Ən çox yoxlanılan mövzulardandır:

```java
// Two Pointer texnikası
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[]{map.get(complement), i};
        }
        map.put(nums[i], i);
    }
    
    return new int[0];
}

// Sliding Window texnikası  
public int maxSubArray(int[] nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];
    
    for (int i = 1; i < nums.length; i++) {
        currentSum = Math.max(nums[i], currentSum + nums[i]);
        maxSum = Math.max(maxSum, currentSum);
    }
    
    return maxSum;
}
```

### 2. Linked List
Pointer manipulasiyası və cycle detection:

```java
public class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; }
}

// Linked List reverse etmək
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode current = head;
    
    while (current != null) {
        ListNode next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    
    return prev;
}

// Cycle detection (Floyd's Algorithm)
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) return false;
    
    ListNode slow = head;
    ListNode fast = head.next;
    
    while (fast != null && fast.next != null) {
        if (slow == fast) return true;
        slow = slow.next;
        fast = fast.next.next;
    }
    
    return false;
}
```

### 3. Tree və Graph
DFS/BFS alqoritmləri:

```java
// Binary Tree DFS (Preorder)
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    if (root == null) return result;
    
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        result.add(node.val);
        
        if (node.right != null) stack.push(node.right);
        if (node.left != null) stack.push(node.left);
    }
    
    return result;
}

// Binary Tree BFS (Level Order)
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> level = new ArrayList<>();
        
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            level.add(node.val);
            
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        
        result.add(level);
    }
    
    return result;
}
```

### 4. Dynamic Programming
Optimal substructure və overlapping subproblems:

```java
// Fibonacci DP həlli
public int fib(int n) {
    if (n <= 1) return n;
    
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];
    }
    
    return dp[n];
}

// Coin Change problemi
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    
    for (int coin : coins) {
        for (int i = coin; i <= amount; i++) {
            dp[i] = Math.min(dp[i], dp[i - coin] + 1);
        }
    }
    
    return dp[amount] > amount ? -1 : dp[amount];
}
```

## Interview Strategiyaları

### ✅ Edin:
- **Problemin həllini yüksək səslə düşünün**
- **Sadə həlldən başlayın, sonra optimallaşdırın**
- **Variable adlarını mənalı seçin**
- **Edge case-ləri nəzərə alın**
- **Kompleksliyi təhlil edin**

### ❌ Etməyin:
- **Dərhal kod yazmağa başlamayın**
- **Optimal həlli axtarmağa çox vaxt sərf etməyin**
- **Susub qalmayın, fikrinizi bölüşün**
- **Test etməyi unutmayın**

## Complexity Analysis

### Time Complexity
Əsas kompleksliklər:
- **O(1)**: Constant - HashMap lookup
- **O(log n)**: Logarithmic - Binary search
- **O(n)**: Linear - Array iteration
- **O(n log n)**: Linearithmic - Merge sort
- **O(n²)**: Quadratic - Nested loops

### Space Complexity
Əlavə yaddaş istifadəsi:
- **O(1)**: Constant space
- **O(n)**: Linear space - Extra array
- **O(h)**: Tree height - Recursion stack

## Populyar Interview Sualları

### Easy Level:
1. **Two Sum** - HashMap istifadəsi
2. **Valid Parentheses** - Stack structure
3. **Merge Two Sorted Lists** - Pointer manipulation
4. **Maximum Depth of Binary Tree** - Recursion

### Medium Level:
1. **Longest Substring Without Repeating Characters** - Sliding window
2. **Add Two Numbers** - Linked list arithmetic
3. **Group Anagrams** - String manipulation və HashMap
4. **Binary Tree Inorder Traversal** - Tree traversal

### Hard Level:
1. **Median of Two Sorted Arrays** - Binary search
2. **Regular Expression Matching** - Dynamic programming
3. **Merge k Sorted Lists** - Heap/Priority queue

## Hazırlıq Resurslari

1. **LeetCode**: 150+ problem həll edin
2. **HackerRank**: Algorithm track
3. **Pramp**: Mock interview
4. **AlgoExpert**: Strukturlaşdırılmış kurs

**Unutmayın:** Coding interview məharət tələb edir. Gündəlik praktika və müxtəlif problem növlərini həll etmək uğur açarıdır.