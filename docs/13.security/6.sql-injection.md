---
title: SQL Injection
sidebar_label: SQL Injection
description: SQL injection hücumları və müdafiə metodları
slug: security/sql-injection
tags: [sql-injection, security, database-security, owasp, prepared-statements]
keywords: [sql injection, database security, prepared statements, parameterized queries]
hide_table_of_contents: false
---

# SQL Injection

- **SQL Injection:** Zərərli SQL kodlarının tətbiqetməyə daxil edilərək verilənlər bazasında icazəsiz əməliyyatların aparılması.
- **Input Validation:** İstifadəçi girişlərinin düzgün yoxlanılmaması nəticəsində baş verir.
- **Dynamic SQL:** String concatenation ilə SQL sorğularının qurulması əsas risk faktoru.
- **OWASP Top 10:** A03 - Injection kateqoriyasında yer alır.
- **Kritik Risk:** Məlumat oğurluğu, dəyişdirilməsi və ya silinməsinə səbəb ola bilər.

## SQL Injection Növləri

### 1. Classic SQL Injection

**Zəif Kod:**
```java
// TEHLÜKƏLİ - Heç vaxt belə etməyin!
@Repository
public class UserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public User findByUsername(String username) {
        String sql = "SELECT * FROM users WHERE username = '" + username + "'";
        return jdbcTemplate.queryForObject(sql, new UserRowMapper());
    }
    
    public List<User> searchUsers(String searchTerm) {
        String sql = "SELECT * FROM users WHERE name LIKE '%" + searchTerm + "%'";
        return jdbcTemplate.query(sql, new UserRowMapper());
    }
}
```

**Hücum Nümunəsi:**
```sql
-- Normal istifadə
username: john
SQL: SELECT * FROM users WHERE username = 'john'

-- SQL Injection hücumu
username: admin' OR '1'='1
SQL: SELECT * FROM users WHERE username = 'admin' OR '1'='1'

-- Məlumat bazasını silən hücum
username: admin'; DROP TABLE users; --
SQL: SELECT * FROM users WHERE username = 'admin'; DROP TABLE users; --'
```

### 2. Blind SQL Injection

**Zaman əsaslı:**
```sql
-- Response time ilə məlumat çıxartma
username: admin' AND (SELECT COUNT(*) FROM users) > 10 AND SLEEP(5) --

-- Boolean əsaslı
username: admin' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='admin') = 'a' --
```

**Java-da test:**
```java
// Zəif kod - blind injection üçün həssas
public boolean checkUserExists(String username) {
    String sql = "SELECT COUNT(*) FROM users WHERE username = '" + username + "'";
    int count = jdbcTemplate.queryForObject(sql, Integer.class);
    return count > 0;
}
```

### 3. Union-based SQL Injection

```sql
-- Başqa cədvəllərdən məlumat əldə etmə
username: admin' UNION SELECT username,password,email FROM admin_users --

-- Sistem məlumatlarını əldə etmə
username: admin' UNION SELECT table_name,column_name,'' FROM information_schema.columns --
```

## Təhlükəsiz Kodlaşdırma Praktikaları

### 1. Prepared Statements (Parameterized Queries)

**Spring JDBC:**
```java
@Repository
public class SecureUserRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public User findByUsername(String username) {
        String sql = "SELECT * FROM users WHERE username = ?";
        return jdbcTemplate.queryForObject(sql, new UserRowMapper(), username);
    }
    
    public List<User> searchUsers(String searchTerm) {
        String sql = "SELECT * FROM users WHERE name LIKE ?";
        return jdbcTemplate.query(sql, new UserRowMapper(), "%" + searchTerm + "%");
    }
    
    public void updateUserEmail(Long userId, String email) {
        String sql = "UPDATE users SET email = ? WHERE id = ?";
        jdbcTemplate.update(sql, email, userId);
    }
}
```

**JPA/Hibernate:**
```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Method query - avtomatik təhlükəsiz
    List<User> findByUsernameContaining(String username);
    
    // Named parameters ilə
    @Query("SELECT u FROM User u WHERE u.email = :email")
    Optional<User> findByEmail(@Param("email") String email);
    
    // Native query ilə parameterlər
    @Query(value = "SELECT * FROM users WHERE status = ? AND created_date > ?", 
           nativeQuery = true)
    List<User> findActiveUsersAfterDate(String status, Date date);
    
    // Çox mürəkkəb sorğular üçün
    @Query(value = """
        SELECT u.* FROM users u 
        JOIN user_roles ur ON u.id = ur.user_id 
        JOIN roles r ON ur.role_id = r.id 
        WHERE r.name = :roleName AND u.active = :active
        """, nativeQuery = true)
    List<User> findUsersByRoleAndStatus(@Param("roleName") String roleName, 
                                       @Param("active") boolean active);
}
```

### 2. Stored Procedures

**Stored Procedure yaradılması:**
```sql
DELIMITER //
CREATE PROCEDURE GetUserByUsername(IN p_username VARCHAR(255))
BEGIN
    SELECT * FROM users WHERE username = p_username;
END //
DELIMITER ;
```

**Java-da çağırış:**
```java
@Repository
public class UserStoredProcRepository {
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    public User findByUsername(String username) {
        SimpleJdbcCall jdbcCall = new SimpleJdbcCall(jdbcTemplate)
            .withProcedureName("GetUserByUsername");
        
        SqlParameterSource params = new MapSqlParameterSource()
            .addValue("p_username", username);
        
        Map<String, Object> result = jdbcCall.execute(params);
        // Result processing...
    }
}
```

### 3. Input Validation və Sanitization

**Validation Annotations:**
```java
public class UserSearchRequest {
    
    @NotBlank(message = "Search term cannot be blank")
    @Size(min = 2, max = 50, message = "Search term must be between 2 and 50 characters")
    @Pattern(regexp = "^[a-zA-Z0-9\\s]*$", message = "Only alphanumeric characters allowed")
    private String searchTerm;
    
    @Valid
    @NotNull
    private SearchFilters filters;
    
    // getters/setters
}

@Component
public class InputSanitizer {
    
    public String sanitizeForSql(String input) {
        if (input == null) return null;
        
        return input
            .replaceAll("'", "''")  // Single quote escape
            .replaceAll(";", "")    // Remove semicolons
            .replaceAll("--", "")   // Remove comments
            .replaceAll("/\\*", "") // Remove block comments
            .replaceAll("\\*/", "")
            .trim();
    }
    
    public String sanitizeAlphanumeric(String input) {
        if (input == null) return null;
        return input.replaceAll("[^a-zA-Z0-9]", "");
    }
}
```

### 4. Whitelist Approach

**Allowed Values:**
```java
@Service
public class SecureSearchService {
    
    private static final Set<String> ALLOWED_SORT_COLUMNS = Set.of(
        "id", "username", "email", "created_date", "last_login"
    );
    
    private static final Set<String> ALLOWED_SORT_DIRECTIONS = Set.of("ASC", "DESC");
    
    public List<User> searchUsers(String searchTerm, String sortColumn, String sortDirection) {
        // Validate sort column
        if (!ALLOWED_SORT_COLUMNS.contains(sortColumn)) {
            throw new IllegalArgumentException("Invalid sort column: " + sortColumn);
        }
        
        // Validate sort direction
        if (!ALLOWED_SORT_DIRECTIONS.contains(sortDirection.toUpperCase())) {
            throw new IllegalArgumentException("Invalid sort direction: " + sortDirection);
        }
        
        String sql = "SELECT * FROM users WHERE username LIKE ? ORDER BY " + 
                     sortColumn + " " + sortDirection;
        
        return jdbcTemplate.query(sql, new UserRowMapper(), "%" + searchTerm + "%");
    }
}
```

## Framework-specific Qorunma

### Spring Security

**SQL Injection Detection:**
```java
@Component
public class SqlInjectionDetectionFilter implements Filter {
    
    private static final Pattern SQL_INJECTION_PATTERN = Pattern.compile(
        "('.+(\\bOR\\b|\\bAND\\b).+'.+)|" +
        "('.*(\\bUNION\\b|\\bSELECT\\b|\\bINSERT\\b|\\bDELETE\\b|\\bUPDATE\\b|\\bDROP\\b).*')|" +
        "(\\b(SELECT|INSERT|DELETE|UPDATE|DROP|UNION)\\b.*\\b(FROM|INTO|SET|WHERE|JOIN)\\b)"
    );
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        
        // Check all parameters
        for (String paramName : httpRequest.getParameterMap().keySet()) {
            String[] paramValues = httpRequest.getParameterValues(paramName);
            for (String paramValue : paramValues) {
                if (containsSqlInjection(paramValue)) {
                    logger.warn("SQL injection attempt detected: {} = {}", paramName, paramValue);
                    
                    HttpServletResponse httpResponse = (HttpServletResponse) response;
                    httpResponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);
                    httpResponse.getWriter().write("Malicious input detected");
                    return;
                }
            }
        }
        
        chain.doFilter(request, response);
    }
    
    private boolean containsSqlInjection(String input) {
        return input != null && SQL_INJECTION_PATTERN.matcher(input.toUpperCase()).find();
    }
}
```

### MyBatis

**Təhlükəsiz MyBatis istifadəsi:**
```xml
<!-- mapper.xml -->
<mapper namespace="com.example.UserMapper">
    
    <!-- Parametric query - təhlükəsiz -->
    <select id="findByUsername" parameterType="string" resultType="User">
        SELECT * FROM users WHERE username = #{username}
    </select>
    
    <!-- Dynamic WHERE conditions -->
    <select id="searchUsers" parameterType="map" resultType="User">
        SELECT * FROM users 
        <where>
            <if test="username != null">
                AND username LIKE CONCAT('%', #{username}, '%')
            </if>
            <if test="email != null">
                AND email = #{email}
            </if>
            <if test="active != null">
                AND active = #{active}
            </if>
        </where>
    </select>
    
    <!-- TEHLÜKƏLİ - ${} istifadəsi -->
    <select id="dangerousQuery" parameterType="string" resultType="User">
        SELECT * FROM users WHERE username = '${username}' -- SQL Injection riski!
    </select>
</mapper>
```

**Java Interface:**
```java
@Mapper
public interface UserMapper {
    
    User findByUsername(@Param("username") String username);
    
    List<User> searchUsers(@Param("username") String username, 
                          @Param("email") String email, 
                          @Param("active") Boolean active);
    
    // Dynamic ORDER BY - təhlükəsiz yolu
    @Select({
        "<script>",
        "SELECT * FROM users",
        "WHERE status = #{status}",
        "<choose>",
        "<when test='sortBy == \"username\"'>ORDER BY username ${sortDir}</when>",
        "<when test='sortBy == \"email\"'>ORDER BY email ${sortDir}</when>", 
        "<otherwise>ORDER BY id ASC</otherwise>",
        "</choose>",
        "</script>"
    })
    List<User> findUsersWithDynamicSort(@Param("status") String status,
                                       @Param("sortBy") String sortBy,
                                       @Param("sortDir") String sortDir);
}
```

## Database Səviyyəsində Qorunma

### 1. Database Permissions

**Minimum Privilege Principle:**
```sql
-- Application üçün məhdud istifadəçi yarat
CREATE USER 'app_user'@'localhost' IDENTIFIED BY 'secure_password';

-- Yalnız lazımi icazələri ver
GRANT SELECT, INSERT, UPDATE ON myapp.users TO 'app_user'@'localhost';
GRANT SELECT, INSERT, UPDATE ON myapp.orders TO 'app_user'@'localhost';

-- DROP, ALTER kimi təhlükəli icazələri vermə
-- REVOKE ALL PRIVILEGES ON *.* FROM 'app_user'@'localhost';

-- Admin əməliyyatları üçün ayrı istifadəçi
CREATE USER 'admin_user'@'localhost' IDENTIFIED BY 'admin_password';
GRANT ALL PRIVILEGES ON myapp.* TO 'admin_user'@'localhost';
```

### 2. Database Configuration

**MySQL təhlükəsizlik təkmilləşdirmələri:**
```sql
-- SQL mode-u sərtləşdir
SET sql_mode = 'STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION';

-- Query cache-i deaktiv et (injection cache-ə düşməsin)
SET global query_cache_type = OFF;

-- Error mesajlarını məhdudlaşdır
SET global log_warnings = 0;
```

**PostgreSQL:**
```sql
-- Row level security aktiv et
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- Policy yarat
CREATE POLICY user_policy ON users 
    USING (user_id = current_setting('app.current_user_id')::INTEGER);
```

## Testing və Detection

### 1. Automated SQL Injection Testing

**JUnit Test:**
```java
@SpringBootTest
@Transactional
public class SqlInjectionTest {
    
    @Autowired
    private UserService userService;
    
    @Test
    public void testSqlInjectionInUsername() {
        String maliciousInput = "admin' OR '1'='1' --";
        
        // Bu test fail olmamalıdır (injection işləməməlidir)
        assertThatThrownBy(() -> userService.findByUsername(maliciousInput))
            .isInstanceOf(DataAccessException.class);
    }
    
    @Test
    public void testUnionBasedInjection() {
        String unionAttack = "admin' UNION SELECT username,password,null FROM admin_users --";
        
        List<User> result = userService.searchUsers(unionAttack);
        
        // Normal axtarış nəticəsi alınmalıdır, ek məlumat yox
        assertThat(result).allMatch(user -> user.getClass().equals(User.class));
    }
    
    @Test
    public void testBlindSqlInjection() {
        String timeBasedAttack = "admin' AND SLEEP(5) --";
        
        long startTime = System.currentTimeMillis();
        userService.checkUserExists(timeBasedAttack);
        long endTime = System.currentTimeMillis();
        
        // Response time normal olmalıdır (5 saniyə gözləməməlidir)
        assertThat(endTime - startTime).isLessThan(1000);
    }
}
```

### 2. SAST (Static Application Security Testing)

**SonarQube rule-ları:**
```java
// SonarQube tərəfindən aşkarlanacaq
public void vulnerableMethod(String input) {
    String sql = "SELECT * FROM users WHERE id = " + input; // SQUID:S2077
    jdbcTemplate.queryForObject(sql, User.class);
}
```

### 3. DAST (Dynamic Application Security Testing)

**OWASP ZAP integration:**
```java
@Test
public void zapSecurityTest() {
    // ZAP proxy ilə SQL injection testləri
    ClientApi zapClient = new ClientApi("localhost", 8080);
    
    // Spider attack
    zapClient.spider.scan("http://localhost:8080");
    
    // SQL injection test
    zapClient.ascan.scan("http://localhost:8080", "True", "False", null, null, null);
    
    // Nəticələri yoxla
    List<Alert> alerts = zapClient.core.alerts("High");
    assertThat(alerts).isEmpty(); // Yüksək risk tapılmamalıdır
}
```

## Logging və Monitoring

### 1. Attack Detection

```java
@Component
public class SecurityAuditLogger {
    
    private static final Logger securityLogger = LoggerFactory.getLogger("SECURITY");
    
    public void logSqlInjectionAttempt(String username, String input, String endpoint) {
        securityLogger.warn(
            "SQL_INJECTION_ATTEMPT: user={}, input={}, endpoint={}, timestamp={}", 
            username, 
            sanitizeForLog(input), 
            endpoint, 
            Instant.now()
        );
        
        // Metrics
        Metrics.counter("security.sql_injection_attempts", 
                       "endpoint", endpoint,
                       "user", username).increment();
    }
    
    private String sanitizeForLog(String input) {
        return input.length() > 100 ? input.substring(0, 100) + "..." : input;
    }
}
```

### 2. Database Query Monitoring

```java
@Configuration
public class DatabaseMonitoringConfig {
    
    @Bean
    public ProxyDataSource dataSource(@Qualifier("actualDataSource") DataSource dataSource) {
        return ProxyDataSourceBuilder
            .create(dataSource)
            .name("MyDS")
            .listener(new SqlInjectionDetectionListener())
            .build();
    }
}

public class SqlInjectionDetectionListener implements QueryExecutionListener {
    
    private static final Pattern SUSPICIOUS_PATTERNS = Pattern.compile(
        ".*(UNION|OR 1=1|DROP TABLE|INSERT INTO|UPDATE.*SET).*", 
        Pattern.CASE_INSENSITIVE
    );
    
    @Override
    public void beforeQuery(ExecutionInfo execInfo, List<QueryInfo> queryInfoList) {
        for (QueryInfo queryInfo : queryInfoList) {
            String query = queryInfo.getQuery();
            if (SUSPICIOUS_PATTERNS.matcher(query).matches()) {
                logger.warn("Suspicious SQL detected: {}", query);
                // Alert göndər
            }
        }
    }
}
```

SQL injection-dan qorunmaq üçün həmişə parameterized query-lərdən istifadə edin və input validation tətbiq edin.
