---
title: Rate Limiting
sidebar_label: Rate Limiting
description: Rate limiting strategiyaları və tətbiq metodları
slug: security/rate-limiting
tags: [rate-limiting, security, api-security, throttling, dos-protection]
keywords: [rate limiting, throttling, api security, dos protection, bucket algorithm]
hide_table_of_contents: false
---

# Rate Limiting

- **Rate Limiting:** API və ya veb xidmətlərinə edilən sorğuların sayını müəyyən müddət ərzində məhdudlaşdıran təhlükəsizlik mexanizmi.
- **DoS Müdafiəsi:** Denial of Service hücumlarının qarşısını almaq üçün istifadə edilir.
- **Resource Qorunması:** Server resurslarının düzgün paylanmasını təmin edir.
- **Fair Usage:** Bütün istifadəçilərin ədalətli şəkildə xidmətdən istifadə etməsini təmin edir.
- **Abuse Prevention:** API sui-istifadəsinin qarşısını alır.

## Rate Limiting Alqoritmləri

### 1. Token Bucket Algorithm

**Prinsip:** Bucket-də token-lər saxlanılır, hər sorğu üçün token istifadə olunur.

```java
@Component
public class TokenBucketRateLimiter {
    
    private final Map<String, Bucket> buckets = new ConcurrentHashMap<>();
    private final int capacity;
    private final int refillRate;
    
    public TokenBucketRateLimiter(int capacity, int refillRatePerSecond) {
        this.capacity = capacity;
        this.refillRate = refillRatePerSecond;
    }
    
    public boolean tryConsume(String key) {
        Bucket bucket = buckets.computeIfAbsent(key, k -> createBucket());
        return bucket.tryConsume(1);
    }
    
    private Bucket createBucket() {
        Bandwidth bandwidth = Bandwidth.classic(capacity, Refill.intervally(refillRate, Duration.ofSeconds(1)));
        return Bucket4j.builder()
            .addLimit(bandwidth)
            .build();
    }
    
    @Scheduled(fixedRate = 300000) // 5 dəqiqə
    public void cleanup() {
        buckets.entrySet().removeIf(entry -> 
            entry.getValue().getAvailableTokens() == capacity);
    }
}
```

### 2. Fixed Window Algorithm

**Prinsip:** Müəyyən vaxt pəncərəsində sorğu sayını məhdudlaşdırır.

```java
@Component
public class FixedWindowRateLimiter {
    
    private final RedisTemplate<String, String> redisTemplate;
    private final int limit;
    private final Duration windowSize;
    
    public boolean isAllowed(String key) {
        String redisKey = "rate_limit:" + key + ":" + getCurrentWindow();
        
        String count = redisTemplate.opsForValue().get(redisKey);
        int currentCount = count != null ? Integer.parseInt(count) : 0;
        
        if (currentCount >= limit) {
            return false;
        }
        
        redisTemplate.opsForValue().increment(redisKey);
        redisTemplate.expire(redisKey, windowSize);
        
        return true;
    }
    
    private long getCurrentWindow() {
        return System.currentTimeMillis() / windowSize.toMillis();
    }
}
```

### 3. Sliding Window Log Algorithm

**Prinsip:** Hər sorğunun vaxtını saxlayır və sliding window istifadə edir.

```java
@Component
public class SlidingWindowLogRateLimiter {
    
    private final RedisTemplate<String, String> redisTemplate;
    private final int limit;
    private final Duration windowSize;
    
    public boolean isAllowed(String key) {
        String redisKey = "sliding_window:" + key;
        long now = System.currentTimeMillis();
        long windowStart = now - windowSize.toMillis();
        
        // Köhnə entry-ləri sil
        redisTemplate.opsForZSet().removeRangeByScore(redisKey, 0, windowStart);
        
        // Hazırkı sorğu sayını yoxla
        Long currentCount = redisTemplate.opsForZSet().count(redisKey, windowStart, now);
        
        if (currentCount >= limit) {
            return false;
        }
        
        // Yeni sorğunu əlavə et
        redisTemplate.opsForZSet().add(redisKey, UUID.randomUUID().toString(), now);
        redisTemplate.expire(redisKey, windowSize);
        
        return true;
    }
}
```

### 4. Sliding Window Counter Algorithm

**Prinsip:** Fixed window və sliding window-un kombinasiyası.

```java
@Component
public class SlidingWindowCounterRateLimiter {
    
    private final RedisTemplate<String, String> redisTemplate;
    private final int limit;
    private final Duration windowSize;
    private final int subWindows;
    
    public boolean isAllowed(String key) {
        long now = System.currentTimeMillis();
        long windowSizeMs = windowSize.toMillis();
        long subWindowSizeMs = windowSizeMs / subWindows;
        
        long currentWindow = now / subWindowSizeMs;
        long previousWindow = currentWindow - 1;
        
        String currentKey = "sliding_counter:" + key + ":" + currentWindow;
        String previousKey = "sliding_counter:" + key + ":" + previousWindow;
        
        // Hazırkı və əvvəlki window-dan sorğu sayını al
        int currentCount = getCount(currentKey);
        int previousCount = getCount(previousKey);
        
        // Sliding hesablama
        double timeInCurrentWindow = (now % subWindowSizeMs) / (double) subWindowSizeMs;
        double estimatedCount = previousCount * (1 - timeInCurrentWindow) + currentCount;
        
        if (estimatedCount >= limit) {
            return false;
        }
        
        // Sorğu sayını artır
        redisTemplate.opsForValue().increment(currentKey);
        redisTemplate.expire(currentKey, windowSize);
        
        return true;
    }
    
    private int getCount(String key) {
        String value = redisTemplate.opsForValue().get(key);
        return value != null ? Integer.parseInt(value) : 0;
    }
}
```

## Spring Boot Tətbiqi

### 1. Rate Limiting Filter

```java
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
public class RateLimitingFilter implements Filter {
    
    private final TokenBucketRateLimiter rateLimiter;
    private final ObjectMapper objectMapper;
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        String clientId = extractClientId(httpRequest);
        
        if (!rateLimiter.tryConsume(clientId)) {
            handleRateLimitExceeded(httpResponse);
            return;
        }
        
        chain.doFilter(request, response);
    }
    
    private String extractClientId(HttpServletRequest request) {
        // API key əsaslı
        String apiKey = request.getHeader("X-API-KEY");
        if (apiKey != null) {
            return "api:" + apiKey;
        }
        
        // IP əsaslı
        return "ip:" + getClientIpAddress(request);
    }
    
    private void handleRateLimitExceeded(HttpServletResponse response) throws IOException {
        response.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        
        RateLimitResponse errorResponse = RateLimitResponse.builder()
            .error("Rate limit exceeded")
            .message("Too many requests. Please try again later.")
            .retryAfter(60)
            .build();
        
        response.getWriter().write(objectMapper.writeValueAsString(errorResponse));
    }
}
```

### 2. Annotation-based Rate Limiting

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    int value() default 100;
    TimeUnit timeUnit() default TimeUnit.MINUTES;
    String key() default "";
    RateLimitType type() default RateLimitType.IP;
}

public enum RateLimitType {
    IP, USER, API_KEY, CUSTOM
}
```

**Aspect Implementation:**

```java
@Aspect
@Component
public class RateLimitAspect {
    
    private final TokenBucketRateLimiter rateLimiter;
    
    @Around("@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint joinPoint, RateLimit rateLimit) throws Throwable {
        
        String key = buildRateLimitKey(rateLimit);
        
        if (!rateLimiter.tryConsume(key, rateLimit.value())) {
            throw new RateLimitExceededException("Rate limit exceeded for key: " + key);
        }
        
        return joinPoint.proceed();
    }
    
    private String buildRateLimitKey(RateLimit rateLimit) {
        HttpServletRequest request = getCurrentRequest();
        
        switch (rateLimit.type()) {
            case IP:
                return "ip:" + getClientIpAddress(request);
            case USER:
                return "user:" + getCurrentUserId();
            case API_KEY:
                return "api:" + request.getHeader("X-API-KEY");
            case CUSTOM:
                return rateLimit.key();
            default:
                return "default";
        }
    }
}
```

**İstifadə:**

```java
@RestController
public class ApiController {
    
    @GetMapping("/public/data")
    @RateLimit(value = 10, timeUnit = TimeUnit.MINUTES, type = RateLimitType.IP)
    public ResponseEntity<DataResponse> getPublicData() {
        return ResponseEntity.ok(dataService.getPublicData());
    }
    
    @PostMapping("/api/upload")
    @RateLimit(value = 5, timeUnit = TimeUnit.HOURS, type = RateLimitType.USER)
    public ResponseEntity<UploadResponse> uploadFile(@RequestBody MultipartFile file) {
        return ResponseEntity.ok(fileService.uploadFile(file));
    }
}
```

## Redis ilə Distributed Rate Limiting

### Redis Lua Script

```java
@Component
public class RedisRateLimiter {
    
    private final RedisTemplate<String, String> redisTemplate;
    
    private static final String RATE_LIMIT_SCRIPT = """
        local key = KEYS[1]
        local limit = tonumber(ARGV[1])
        local window = tonumber(ARGV[2])
        local current_time = tonumber(ARGV[3])
        
        local current = redis.call('GET', key)
        if current == false then
            redis.call('SET', key, 1)
            redis.call('EXPIRE', key, window)
            return {1, limit - 1, window}
        end
        
        current = tonumber(current)
        if current < limit then
            local new_count = redis.call('INCR', key)
            local ttl = redis.call('TTL', key)
            return {new_count, limit - new_count, ttl}
        else
            local ttl = redis.call('TTL', key)
            return {current, 0, ttl}
        end
        """;
    
    public RateLimitResult checkRateLimit(String key, int limit, int windowSeconds) {
        RedisScript<List> script = RedisScript.of(RATE_LIMIT_SCRIPT, List.class);
        
        List<Object> result = redisTemplate.execute(script, 
            Collections.singletonList(key),
            String.valueOf(limit),
            String.valueOf(windowSeconds),
            String.valueOf(System.currentTimeMillis() / 1000)
        );
        
        int currentCount = ((Number) result.get(0)).intValue();
        int remaining = ((Number) result.get(1)).intValue();
        int resetTime = ((Number) result.get(2)).intValue();
        
        return RateLimitResult.builder()
            .allowed(remaining > 0)
            .currentCount(currentCount)
            .remaining(remaining)
            .resetTime(resetTime)
            .build();
    }
}
```

## Advanced Rate Limiting Patterns

### 1. Tiered Rate Limiting

```java
@Service
public class TieredRateLimiter {
    
    public enum UserTier {
        FREE(100, Duration.ofHours(1)),
        PREMIUM(1000, Duration.ofHours(1)),
        ENTERPRISE(10000, Duration.ofHours(1));
        
        private final int limit;
        private final Duration window;
        
        UserTier(int limit, Duration window) {
            this.limit = limit;
            this.window = window;
        }
        
        // getters
    }
    
    public boolean isAllowed(String userId) {
        UserTier tier = userService.getUserTier(userId);
        String key = "user:" + userId + ":" + tier.name();
        
        return rateLimiter.isAllowed(key, tier.getLimit(), tier.getWindow());
    }
}
```

### 2. Adaptive Rate Limiting

```java
@Service
public class AdaptiveRateLimiter {
    
    private final MetricService metricService;
    private volatile int currentLimit = 1000;
    
    @Scheduled(fixedRate = 30000) // 30 saniyə
    public void adjustRateLimit() {
        double cpuUsage = metricService.getCpuUsage();
        double memoryUsage = metricService.getMemoryUsage();
        int responseTime = metricService.getAverageResponseTime();
        
        if (cpuUsage > 80 || memoryUsage > 85 || responseTime > 500) {
            currentLimit = Math.max(100, (int) (currentLimit * 0.8));
        } else if (cpuUsage < 50 && memoryUsage < 60 && responseTime < 200) {
            currentLimit = Math.min(2000, (int) (currentLimit * 1.1));
        }
        
        logger.info("Adjusted rate limit to: {}", currentLimit);
    }
    
    public boolean isAllowed(String key) {
        return rateLimiter.tryConsume(key, currentLimit);
    }
}
```

### 3. Weighted Rate Limiting

```java
@Service
public class WeightedRateLimiter {
    
    private final Map<String, Integer> endpointWeights = Map.of(
        "/api/search", 1,
        "/api/upload", 5,
        "/api/process", 10,
        "/api/report", 3
    );
    
    public boolean isAllowed(String userId, String endpoint) {
        int weight = endpointWeights.getOrDefault(endpoint, 1);
        String key = "weighted:" + userId;
        
        return rateLimiter.tryConsume(key, weight);
    }
}
```

## Rate Limiting Headers

### Standard Headers

```java
@Component
public class RateLimitHeadersFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        String key = extractKey(httpRequest);
        RateLimitResult result = rateLimiter.checkRateLimit(key);
        
        // Rate limiting headers əlavə et
        httpResponse.setHeader("X-RateLimit-Limit", String.valueOf(result.getLimit()));
        httpResponse.setHeader("X-RateLimit-Remaining", String.valueOf(result.getRemaining()));
        httpResponse.setHeader("X-RateLimit-Reset", String.valueOf(result.getResetTime()));
        
        if (!result.isAllowed()) {
            httpResponse.setHeader("Retry-After", String.valueOf(result.getRetryAfter()));
            httpResponse.setStatus(HttpStatus.TOO_MANY_REQUESTS.value());
            return;
        }
        
        chain.doFilter(request, response);
    }
}
```

## API Gateway Rate Limiting

### Spring Cloud Gateway

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: api-route
          uri: http://localhost:8081
          predicates:
            - Path=/api/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenish-rate: 10
                redis-rate-limiter.burst-capacity: 20
                redis-rate-limiter.requested-tokens: 1
                key-resolver: "#{@userKeyResolver}"
```

```java
@Bean
public KeyResolver userKeyResolver() {
    return exchange -> exchange.getRequest().getHeaders().getFirst("X-User-ID");
}

@Bean
public KeyResolver ipKeyResolver() {
    return exchange -> {
        String clientIp = exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();
        return Mono.just(clientIp);
    };
}
```

## Monitoring və Alerting

### Rate Limit Metrics

```java
@Component
public class RateLimitMetrics {
    
    private final MeterRegistry meterRegistry;
    private final Counter rateLimitExceededCounter;
    private final Timer rateLimitCheckTimer;
    
    public RateLimitMetrics(MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
        this.rateLimitExceededCounter = Counter.builder("rate_limit_exceeded")
            .description("Number of rate limit exceeded events")
            .register(meterRegistry);
        this.rateLimitCheckTimer = Timer.builder("rate_limit_check_duration")
            .description("Time taken to check rate limit")
            .register(meterRegistry);
    }
    
    public void recordRateLimitExceeded(String key, String endpoint) {
        rateLimitExceededCounter.increment(
            Tags.of(
                Tag.of("key", key),
                Tag.of("endpoint", endpoint)
            )
        );
    }
    
    public Timer.Sample startTimer() {
        return Timer.start(meterRegistry);
    }
}
```

### Health Check

```java
@Component
public class RateLimiterHealthIndicator implements HealthIndicator {
    
    private final RedisTemplate<String, String> redisTemplate;
    
    @Override
    public Health health() {
        try {
            // Redis connection test
            redisTemplate.opsForValue().get("health_check");
            
            // Rate limiter test
            boolean testResult = rateLimiter.tryConsume("health_check", 1);
            
            return Health.up()
                .withDetail("redis", "UP")
                .withDetail("rate_limiter", testResult ? "UP" : "DOWN")
                .build();
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
