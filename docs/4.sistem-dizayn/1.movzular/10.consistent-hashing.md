---
slug: /consistent-hashing
tags: [consistent-hashing, distributed-systems]
sidebar_position: 10
---

# Consistent Hashing
Consistent Hashing paylanmış sistemlərdə serverlərin əlavə edilməsi və ya çıxarılması zamanı minimal data yenidən paylaşdırma təmin edən hash üsuludur. Bu üsul həlqəvi struktur istifadə edərək scale etmə problemlərini həll edir.

### Nə üçün lazımdır?
- **Minimal data köçürmə:** Server dəyişikliklərində az məlumat yenidən paylaşdırılır
- **Scale etmə asanlığı:** Yeni serverlər əlavə etmək və çıxarmaq sadədir
- **Fault tolerance:** Server nasazlığında sistem işləməyə davam edir
- **Load balancing:** Məlumatları serverlər arasında bərabər paylaşdırır
- **Cache efficiency:** Cache miss-lərini minimuma endirir

### Ənənəvi Hash Problemləri
- **Tam redistribution:** Server sayı dəyişəndə bütün data köçürülməli olur
- **Cache miss storm:** Bütün cache-lər invalid olur və DB-yə yük düşür
- **Scale çətinliyi:** Yeni server əlavə etmək böyük əməliyyat tələb edir
- **Hotspot yaranması:** Bəzi serverlərə çox yük düşür

### Hash Ring İş Prinsipi
- **Həlqəvi struktur:** 0-dan 2³²-1-ə qədər həlqəvi fəza
- **Server yerləşdirmə:** Hər server həlqədə təsadüfi nöqtədə yerləşir
- **Key mapping:** Açar həlqədə yerləşir və saat əqrəbi istiqamətində ilk serverə yönəlir
- **Clockwise axtarış:** Key-dən başlayaraq saat əqrəbi istiqamətində ilk server tapılır

### Virtual Nodes (VNodes)
- **Çox nöqtə:** Hər server həlqədə çoxlu nöqtədə təmsil olunur
- **Bərabər paylaşma:** Load daha bərabər paylaşdırılır
- **Elastiklik:** Server əlavə/çıxarılanda yük bərabər paylanır
- **Hash variations:** DB1-vn1, DB1-vn2 kimi müxtəlif hash-lər

### Həyata Keçirmə Addımları
- **Hash funksiya seçmək:** MD5, SHA-1, SHA-256
- **Hash ring təyin etmək:** 2³² ölçüsündə həlqə
- **Serverləri yerləşdirmək:** Hash(server_id) ilə mövqe təyin etmək
- **Key mapping:** Hash(key) ilə server tapmaq
- **Server əlavə/çıxarma:** Yalnız təsir edən key-ləri yenidən mapping

### Real World İstifadə
- **Apache Cassandra:** Data distribution üçün
- **Amazon DynamoDB:** Sharding üçün
- **Redis Cluster:** Key partitioning üçün
- **CDN-lər:** Content distribution üçün
- **Load Balancers:** Session persistence üçün

### Üstünlüklər və Mənfi Cəhətləri
**Üstünlüklər:**
- Minimal key remapping
- Horizontal scalability
- Fault tolerance
- Load balancing

**Mənfi cəhətlər:**
- Key ordering itir
- Hash function mürəkkəbliyi
- Virtual node konfiqurasiya
- Memory overhead

### Əsas Problemlər
- **Hash function quality:** Pis hash hotspot yaradır → Yaxşı hash (SHA-256) istifadə et
- **Virtual node sayı:** Az vnode load imbalance yaradır → Hər server üçün 100-200 vnode
- **Server failure:** Məlumat itkisi → Replication factor artır (RF=3)
- **Network partitions:** Ring inconsistency → Gossip protocol işlət  
- **Key hotspots:** Bəzi key-lər çox istifadə olunur → Application-level caching əlavə et

```mermaid
graph TB
    subgraph "Hash Ring (0 to 2³²-1)"
        Ring[🔄 Hash Ring]
        Node1[🖥️ Server A<br/>Hash: 100]
        Node2[🖥️ Server B<br/>Hash: 300] 
        Node3[🖥️ Server C<br/>Hash: 500]
        Node4[🖥️ Server D<br/>Hash: 700]
        
        Key1[🔑 Key1: 150<br/>→ Server B]
        Key2[🔑 Key2: 400<br/>→ Server C]
        Key3[🔑 Key3: 600<br/>→ Server D]
        Key4[🔑 Key4: 50<br/>→ Server A]
    end
    
    subgraph "Virtual Nodes"
        VN1[🖥️ Server A<br/>VN1: 80, VN2: 250<br/>VN3: 450, VN4: 650]
        VN2[🖥️ Server B<br/>VN1: 120, VN2: 320<br/>VN3: 520, VN4: 720]
    end
    
    subgraph "Server Operations"
        Add[➕ Server əlavə et<br/>Yalnız təsir edən key-lər köçürülür]
        Remove[➖ Server çıxart<br/>Key-lər növbəti serverə keçir]
        Failure[❌ Server nasazlığı<br/>Avtomatik failover]
    end
    
    subgraph "Ənənəvi Hash vs Consistent Hash"
        Traditional[📊 Modulo Hash<br/>hash #0040;key##0040; % N<br/> Tam redistribution]
        Consistent[🔄 Consistent Hash<br/>Həlqəvi mapping<br/>✅ Minimal köçürmə]
    end
    
    subgraph "Real-World Systems"
        Cassandra[🗂️ Cassandra<br/>Data partitioning]
        DynamoDB[🗄️ DynamoDB<br/>Sharding]
        Redis[🔴 Redis Cluster<br/>Key distribution]
        CDN[🌐 CDN<br/>Content placement]
    end
    
    Ring --> Node1
    Ring --> Node2
    Ring --> Node3
    Ring --> Node4
    
    Node1 -.->|Clockwise| Node2
    Node2 -.->|Clockwise| Node3
    Node3 -.->|Clockwise| Node4
    Node4 -.->|Clockwise| Node1
    
    style Ring fill:#e1f5fe
    style Node1 fill:#e8f5e8
    style Node2 fill:#e8f5e8
    style Node3 fill:#e8f5e8
    style Node4 fill:#e8f5e8
    style Traditional fill:#ffebee
    style Consistent fill:#e8f5e8
    style VN1 fill:#fff3e0
    style VN2 fill:#fff3e0
```




