---
title: Spring REST API Dizayn
sidebar_label: REST
description: Spring Boot ilə REST API dizayn prinsipləri, struktur, səhv idarəsi, versionlama və best practices
slug: spring/rest
tags: [spring, rest, api, http, design]
keywords: [spring rest, api design, error handling, versioning, validation, pagination]
hide_table_of_contents: false
---

# Spring REST API Dizayn

Spring Boot REST API-lərin hazırlanmasını sadələşdirir: `@RestController`, `@GetMapping`, `@RequestBody` və s. ilə deklarativ HTTP interfeysi qurmaq mümkündür. Bu bölmədə dizayn prinsipləri, strukturlaşdırma və ən yaxşı təcrübələr əhatə olunur.

## Əsas Prinsiplər
- **Resource əsaslı URI** (`/users/42/orders`)
- **HTTP Method semantikası** (GET=oxu, POST=yarat, PUT=idempotent yenilə, PATCH=qismən yenilə, DELETE=sil)
- **Stateless server** (session state saxlanmır)
- **Korrekt status kodları** (200, 201, 204, 400, 404, 409, 422, 500 ...)
- **Nəticələrin filter/pagination dəstəyi**
- **Konsistent səhv formatı**

## DTO və Entity Ayrımı
Entity-ləri birbaşa JSON kimi çıxarma: gələcək dəyişikliklərdə API pozulması riskini artırır. DTO layer istifadə et.

<details>
<summary>Koda bax</summary>

```java
public record UserDto(Long id, String username, String email) {}
public record CreateUserRequest(@NotBlank String username, @Email String email, @Size(min=8) String password) {}
```
</details>

## Controller Strukturu
<details>
<summary>Koda bax</summary>

```java
@RestController
@RequestMapping("/api/v1/users")
class UserController {
    private final UserService service;
    UserController(UserService service){ this.service = service; }

    @GetMapping("/{id}")
    public UserDto get(@PathVariable Long id){ return service.get(id); }

    @GetMapping
    public PageResponse<UserDto> list(@RequestParam(defaultValue = "0") int page,
                                      @RequestParam(defaultValue = "20") int size){
        return service.list(page, size);
    }

    @PostMapping
    @ResponseStatus(HttpStatus.CREATED)
    public UserDto create(@Valid @RequestBody CreateUserRequest req){ return service.create(req); }

    @PutMapping("/{id}")
    public UserDto replace(@PathVariable Long id, @Valid @RequestBody UpdateUserRequest req){
        return service.replace(id, req);
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable Long id){ service.delete(id); }
}
```
</details>

## Status Kodları
| Ssenari | Kod | Qeyd |
|---------|-----|------|
| Resurs yaradıldı | 201 | `Location` header ilə |
| Boş cavab (müvəffəqiyyət) | 204 | Body yoxdur |
| Yanlış input | 400 | Validation detalları |
| Tapılmadı | 404 | ID mövcud deyil |
| Konflikt | 409 | Unikal constraint, versiya konflikti |
| Prosesi davam etdirmək mümkün deyil | 422 | Biznes qayda pozuntusu |
| Server daxili xətası | 500 | Gözlənilməz hal |

## Validation və Səhv Formatı
Standart, maşın-oxunaqlı error body dizayn et.
<details>
<summary>Koda bax</summary>

```java
record ApiError(String code, String message, Instant timestamp, Map<String,String> fieldErrors) {}

@RestControllerAdvice
class GlobalErrors {
    @ExceptionHandler(MethodArgumentNotValidException.class)
    ResponseEntity<ApiError> handleValidation(MethodArgumentNotValidException ex){
        Map<String,String> map = ex.getBindingResult().getFieldErrors().stream()
            .collect(Collectors.toMap(FieldError::getField, FieldError::getDefaultMessage, (a,b)->a));
        return ResponseEntity.badRequest().body(
            new ApiError("VALIDATION_ERROR","Validation failed", Instant.now(), map)
        );
    }

    @ExceptionHandler(ResourceNotFoundException.class)
    ResponseEntity<ApiError> notFound(ResourceNotFoundException ex){
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(new ApiError("NOT_FOUND", ex.getMessage(), Instant.now(), Map.of()));
    }
}
```
</details>

## Versionlama Strategiyaları
| Yanaşma | Nümunə | Üstünlük | Çatışmazlıq |
|---------|--------|----------|-------------|
| URI | `/api/v1/users` | Aydın | URI böyüyür |
| Header | `Accept: application/vnd.app.v1+json` | Təmiz URI | Client mürəkkəb |
| Param | `?version=1` | Sadə | Cache zəif |

Ən praktiki: URI + semantic version major dəyişikliyində artır.

## Pagination Formatı
<details>
<summary>Koda bax</summary>

```java
public record PageResponse<T>(List<T> content, int page, int size, long totalElements, int totalPages, boolean last) {}
```
</details>

## Filter və Sort
Query parametrləri: `?page=0&size=20&sort=username,asc&status=ACTIVE`.
Reusable util: Specification və ya QueryDSL (kompleks filter üçün).

## Idempotency
- PUT əməliyyatları idempotent olmalıdır
- POST üçün idempotency-key header (ödəniş kimi əməliyyatlar)
- Retry mexanizmlərində double-submit riskini azaldır

## Caching
| Texnika | Açıqlama |
|---------|----------|
| ETag | Versiya hash qaytar, If-None-Match ilə reuse |
| Cache-Control | max-age, public/private |
| Conditional GET | 304 cavab sürəti artırır |

## HATEOAS (Opsional)
Self & rel link-lər əlavə et, lakin həddindən artıq istifadə etmə (sadə sistemlərdə əlavə mürəkkəblik).

## OpenAPI / Swagger
`springdoc-openapi` istifadə et: avtomatik JSON/YAML + UI.
<details>
<summary>Koda bax</summary>

```java
// build.gradle (misal)
implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.5.0'
```
</details>

## Security Inteqrasiyası
- Endpoint-ləri qrupla: public, authenticated, admin
- Principle məlumatını `@AuthenticationPrincipal` ilə al

## Performans
| Mövzu | Yanaşma |
|-------|---------|
| Serialization | Jackson @JsonIgnore, View-lar, dto-lar |
| N+1 problem | Fetch join / batch size (JPA) |
| Compression | GZIP (server və client) |
| Connection reuse | HTTP/2 dəstəyi |

## Test Yanaşması
| Səviyyə | Alət |
|---------|------|
| Unit | JUnit + Mockito |
| Slice | `@WebMvcTest` |
| Integration | `@SpringBootTest` + Testcontainers |
| Contract | Spring Cloud Contract / Pact |

## Tez Sual-Cavab
| Sual | Cavab |
|------|-------|
| Niyə entity birbaşa qaytarmamalıyam? | Daxili model sızması, dəyişiklikdə API pozulur |
| Niyə 404 əvəzinə 200 boş list? | Collection sorğularında boş list normaldır |
| PUT vs PATCH fərqi? | PUT tam əvəzləyir, PATCH qismən dəyişir |
| POST da idempotent ola bilər? | Idempotency-Key ilə bəli |

## Ən Yaxşı Təcrübələr
- Konsistent naming (`/users`, `/orders`)
- Serial dəyişikliklər üçün optimistic locking (`@Version`)
- Large payload üçün streaming / pagination məcbur et
- Səhv mesajlarını lokalizasiya etməzdən əvvəl stabil struktur saxla
- Monitor: latency, error rate, throughput (RED / USE metrics)

## Növbəti Addım
Event-driven inteqrasiya üçün: `spring/kafka` və ya messaging üçün `spring/amqp` sənədlərinə keç.

