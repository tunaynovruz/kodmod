---
title: Dependency Injection
sidebar_label: Dependency Injection
description: Spring IoC Container, Bean lifecycle, injection növləri və ən yaxşı təcrübələr
slug: spring/dependency-injection
tags: [spring, java, di, ioc, bean]
keywords: [spring dependency injection, spring ioc container, bean scope, qualifier, profile]
hide_table_of_contents: false
---

# Spring Dependency Injection

Spring **IoC (Inversion of Control) Container** obyektlərin yaradılması, konfiqurasiyası və lifecycle idarəetməsini üstlənərək kodu zəif əlaqəli (loosely coupled) edir. **Dependency Injection (DI)** isə obyektin ehtiyacı olan asılılıqları (dependencies) özünün yaratması əvəzinə kənardan verilməsi prinsipidir.

## Əsas Anlayışlar

| Anlayış | İzah |
|--------|------|
| Bean | Spring konteynerinin idarə etdiyi obyekt |
| ApplicationContext | IoC Container interfeysi (bean-lərin lookup & lifecycle) |
| Configuration Class | @Configuration + @Bean ilə manual bean tərifi |
| Component Scan | @ComponentScan ilə paketlərdə avtomatik discovery |
| Dependency Injection Növləri | Constructor, Setter, Field |
| Scope | Bean-in yaşam arealı (singleton, prototype, request, session ...) |
| Profile | Fərqli mühitlər üçün (dev, prod) fərqli konfiqurasiya |
| Qualifier | Eyni tipdən çox bean olduqda seçim |
| Lifecycle Callback | @PostConstruct, @PreDestroy, SmartLifecycle |

## Bean Yaradılması Yanaşmaları

1. Annotation-Based (@Component, @Service, @Repository, @Controller)
2. Java Config (@Configuration + @Bean)
3. XML (legacy – tövsiyə etmirik)

## Injection Yanaşmaları

| Növ | Tövsiyə | Səbəb |
|-----|---------|-------|
| Constructor | ✅ Ən yaxşı | Immutable və test asan |
| Setter | ⚠️ Opsional | İsteğe bağlı dependency üçün |
| Field | ❌ Tövsiyə olunmur | Reflection, test çətin, immutable deyil |

### Constructor Injection Nümunə

<details>
<summary>Koda bax</summary>

```java
@Service
public class OrderService {
    private final PaymentClient paymentClient;
    private final InventoryClient inventoryClient;

    public OrderService(PaymentClient paymentClient, InventoryClient inventoryClient) {
        this.paymentClient = paymentClient;
        this.inventoryClient = inventoryClient;
    }
}
```
</details>

### @Autowired İstifadəsi
- Constructor injection-da (single constructor) yazmaya da bilərsən.
- Setter və ya field injection edirsənsə tələb olunur.
- Optional dependency üçün `@Autowired(required = false)` istifadə oluna bilər.

## @Qualifier və @Primary
Eyni interfeysin birdən çox implementasiyası olduqda qeyri-müəyyənlik yaranır.

<details>
<summary>Koda bax</summary>

```java
public interface MessageSender { void send(String msg); }

@Component("emailSender")
class EmailSender implements MessageSender { public void send(String msg){ /* ... */ } }

@Component("smsSender")
@Primary
class SmsSender implements MessageSender { public void send(String msg){ /* ... */ } }

@Service
class NotificationService {
    private final MessageSender email;
    private final MessageSender sms;

    public NotificationService(@Qualifier("emailSender") MessageSender email,
                               MessageSender sms) { // @Primary seçilir
        this.email = email;
        this.sms = sms;
    }
}
```
</details>

## Bean Lifecycle
1. Yaradılma (instantiation)
2. Asılılıqların inject olunması
3. @PostConstruct (init)
4. Istifadə fazası
5. Konteyner bağlanarkən @PreDestroy

<details>
<summary>Koda bax</summary>

```java
@Component
class CacheManager {
    @PostConstruct
    void init(){ /* warmup */ }

    @PreDestroy
    void shutdown(){ /* flush */ }
}
```
</details>

## Scope-lar
| Scope | İstifadə Sahəsi |
|-------|-----------------|
| singleton | Default, konteynerdə tək instance |
| prototype | Hər injection-da yeni obyekt |
| request | Web request başına |
| session | HTTP session başına |
| application | ServletContext başına |
| websocket | WebSocket sessiya başına |

<details>
<summary>Koda bax</summary>

```java
@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
@Component
class TaskContext { }
```
</details>

## Lazy Initialization
`@Lazy` ilə bean ilk dəfə istək gəldikdə yaradılır. Məqsəd: startup vaxtını azaltmaq / circular dependency workaround.

```java
@Service
@Lazy
class HeavyService { /* bahalı resource açılışı */ }
```

## @Value və Konfiqurasiya

<details>
<summary>Koda bax</summary>

```java
@Component
class FileStorageProperties {
    @Value("${storage.base-path:/tmp}")
    private String basePath;
}
```
</details>

Daha kompleks konfiqurasiya üçün `@ConfigurationProperties` tövsiyə olunur.

## Profile-lar

<details>
<summary>Koda bax</summary>

```java
@Service
@Profile("dev")
class FakePaymentClient implements PaymentClient { }

@Service
@Profile("prod")
class RealPaymentClient implements PaymentClient { }
```
</details>

Aktivləşdirmə: `SPRING_PROFILES_ACTIVE=prod` və ya `application.yml`.

## Circular Dependency
- Constructor injection ilə aşkarlanır (yaxşıdır).
- Field/setter injection gizlədə bilər.
- Redesign: event publisher, üçüncü mediator bean, interface bölünməsi.

## Ən Yaxşı Təcrübələr
- Constructor injection + `final` fields
- Bean-ləri kiçik və tək məsuliyyətli saxla (SRP)
- Business logic-i @Controller-ə deyil @Service-ə yerləşdir
- @ConfigurationProperties ilə konfiqurasiyanı qrupla
- Field injection-dan uzaq dur
- Dərin object graph-lar varsa modul dizaynı gözdən keçir

## Tez Yoxlama Siyahısı
- Bean lazımdır? Yoxsa sadə util static metod kifayət edir?
- Interface dəyər qatır? Yoxsa premature abstraction-dır?
- Scope doğrudur? (Default olaraq singleton saxla)
- Profile və ya environment-ə həssas hissələr ayrılıb?

## Sual-Cavab
| Sual | Cavab |
|------|-------|
| Niyə field injection pisdir? | Test, immutable və circular problemləri gizlətməsi |
| Bean nə vaxt yaradılır? | Singleton-lar konteyner start-ında (lazy deyilsə) |
| Prototype bean lifecycle kimdə bitir? | Konteyner yalnız yaradılmasını təmin edir |
| @Primary vs @Qualifier | @Primary default seçim, @Qualifier konkret seçim |

## Növbəti Addım
Daha praktiki data qatına keçid üçün: `spring/jdbctemplate` sənədinə bax.

