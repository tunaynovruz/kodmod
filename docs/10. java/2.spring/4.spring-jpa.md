---
title: Spring JPA
sidebar_label: JPA
description: Spring Data JPA ilə entity mapping, repository pattern, əlaqələr, transaction sərhədləri, performance və best practices
slug: spring/jpa
tags: [spring, jpa, data, persistence, orm]
keywords: [spring data jpa, repository, entity mapping, lazy loading, cascade, transaction, locking]
hide_table_of_contents: false
---

# Spring JPA

Spring Data JPA `JPA (Java Persistence API)` üzərində abstraction verərək CRUD əməliyyatlarını sürətləndirməyi, sorğu yazmağı sadələşdirməyi və boilerplate kodu azaltmağı hədəfləyir. Aşağıdakı bölmələrdə əsas konseptlər, annotasiyalar, əlaqə mapping-i, performans və ən yaxşı təcrübələr əhatə olunur.

## Əsas Komponentlər
| Komponent | İzah |
|----------|------|
| Entity | RDB cədvəli ilə xəritələnən Java sinfi |
| EntityManager / Persistence Context | Entity-lərin lifecycle izlənməsi |
| Repository | Data akses interfeysi (CrudRepository / JpaRepository) |
| Transaction | Atomic əməliyyat sərhədləri (@Transactional) |
| Query Methods | Metod adından dinamik sorğu generasiyası |
| JPQL | Entity modeli üzərindən obyekt yönümlü sorğu |
| Criteria API | Tip təhlükəsiz (type-safe) dinamik sorğu |
| Native Query | Raw SQL |

## Lifecycle State-lər
| Hal | İzah |
|-----|------|
| New (Transient) | Persistence context idarəsində deyil |
| Managed (Persistent) | EntityManager izləyir (dirty checking) |
| Detached | Persistence context-dən ayrılıb |
| Removed | Silinmə növbəsində |

## Əsas Annotasiyalar
| Annotasiya | Məqsəd |
|------------|--------|
| `@Entity` | Sinfi entity kimi qeyd edir |
| `@Table(name="...")` | Cədvəl adını set edir |
| `@Id` | Primary key |
| `@GeneratedValue` | ID strategiyası (IDENTITY, SEQUENCE, AUTO) |
| `@Column` | Sütun xüsusiyyətləri |
| `@Enumerated` | Enum saxlanma forması (STRING tövsiyə) |
| `@Temporal` | Tarix tipləri (legacy Date) |
| `@Lob` | BLOB/CLOB |
| `@Embedded` / `@Embeddable` | Dəyər obyektləri |
| `@Version` | Optimistic locking |

<details>
<summary>Koda bax</summary>

```java
@Entity
@Table(name = "users")
public class User {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true, length = 50)
    private String username;

    @Column(nullable = false)
    private String email;

    @Version
    private Long version;

    // getters/setters
}
```
</details>

## Əlaqələr (Relationships)
| Tip | Kartinalıq | Sahib tərəf (owning side) |
|-----|------------|---------------------------|
| `@ManyToOne` | Çox → Bir | Həmişə owning side |
| `@OneToMany` | Bir → Çox | Adətən inverse side (mappedBy) |
| `@OneToOne` | Bir ↔ Bir | Foreign key olan tərəf owning |
| `@ManyToMany` | Çox ↔ Çox | Join table owning təyin edir |

### OneToMany / ManyToOne
<details>
<summary>Koda bax</summary>

```java
@Entity
class Order {
    @Id @GeneratedValue Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private User customer;

    @OneToMany(mappedBy = "order", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<OrderLine> lines = new ArrayList<>();
}

@Entity
class OrderLine {
    @Id @GeneratedValue Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    private Order order;
}
```
</details>

### Helper Metodlar
İkili əlaqələrdə konsistensiyanı qorumaq üçün.
<details>
<summary>Koda bax</summary>

```java
public void addLine(OrderLine l){
    lines.add(l);
    l.setOrder(this);
}

public void removeLine(OrderLine l){
    lines.remove(l);
    l.setOrder(null);
}
```
</details>

## Fetch Strategiyaları
| Fetch | Default Harada | Qeyd |
|-------|---------------|------|
| EAGER | @ManyToOne, @OneToOne | Tövsiyə edilmir (N+1 və şişkin select) |
| LAZY | @OneToMany, @ManyToMany | Tövsiyə: həmişə LAZY saxla |

## N+1 Problemi
| Ssenari | Niyə Baş Verir | Həll |
|---------|----------------|------|
| List entity yüklə + hər biri üçün bağlı obyekt | Hər iterasiyada ayrı select | Fetch join (JPQL), batch size, DTO projection |

<details>
<summary>Koda bax</summary>

```java
// Pis
List<Order> orders = orderRepo.findAll();
for(Order o : orders){ o.getCustomer().getUsername(); }

// Yaxşı (fetch join)
@Query("select o from Order o join fetch o.customer")
List<Order> findAllWithCustomer();
```
</details>

## Cascade & Orphan Removal
| Cascade Tipi | İzah |
|--------------|------|
| PERSIST | Parent persist → child persist |
| MERGE | Update-lər chain |
| REMOVE | Parent silinərsə child sil |
| REFRESH | Refresh chain |
| DETACH | Detach chain |
| ALL | Hamısı |

`orphanRemoval=true` parent list-dən çıxan child üçün DELETE edir.

## DTO Projection
Entity-ləri birbaşa controller-də expose etmə.
<details>
<summary>Koda bax</summary>

```java
public record OrderSummary(Long id, String customerName, int lineCount) {}

@Query("select new com.example.OrderSummary(o.id, c.username, size(o.lines)) " +
       "from Order o join o.customer c")
List<OrderSummary> listSummaries();
```
</details>

## Repository İnterfeysləri
| İnterfeys | Verdiyi |
|----------|---------|
| CrudRepository | basic CRUD |
| PagingAndSortingRepository | pagination + sort |
| JpaRepository | Əlavə JPA spesifik metodlar |

<details>
<summary>Koda bax</summary>

```java
public interface OrderRepository extends JpaRepository<Order, Long> {
    Optional<Order> findByIdAndCustomerUsername(Long id, String username);
    List<Order> findTop10ByOrderByIdDesc();
}
```
</details>

## Custom Sorğular
<details>
<summary>Koda bax</summary>

```java
@Query("select o from Order o where o.createdAt > :from and o.status = :st")
List<Order> findRecent(@Param("from") Instant from, @Param("st") OrderStatus st);

@Query(value = "SELECT * FROM orders o WHERE o.status = ?1", nativeQuery = true)
List<Order> nativeByStatus(String status);
```
</details>

## Pagination və Sort
<details>
<summary>Koda bax</summary>

```java
Page<Order> page = orderRepo.findAll(PageRequest.of(0, 20, Sort.by("createdAt").descending()));
```
</details>

## Transaction Sərhədləri
- `@Transactional` service qatında
- Lazy initialization exception = entity detach + lazy field access (transaction xaricində)
- Read-only sorğularda `@Transactional(readOnly = true)` (optimization hint)

<details>
<summary>Koda bax</summary>

```java
@Service
public class OrderService {
    private final OrderRepository repo;

    public OrderService(OrderRepository repo){ this.repo = repo; }

    @Transactional
    public Long create(CreateOrderRequest req){
        Order o = new Order();
        // xəritələ
        return repo.save(o).getId();
    }

    @Transactional(readOnly = true)
    public OrderDto get(Long id){
        return repo.findById(id).map(OrderMapper::toDto)
            .orElseThrow(() -> new NotFoundException("Tapılmadı"));
    }
}
```
</details>

## Optimistic vs Pessimistic Locking
| Tip | Annotasiya | İstifadə |
|-----|------------|----------|
| Optimistic | `@Version` | Aşağı konflikt halları |
| Pessimistic | `@Lock` (PESSIMISTIC_WRITE) | Yüksək yarışma |

<details>
<summary>Koda bax</summary>

```java
public interface AccountRepository extends JpaRepository<Account, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    Optional<Account> findById(Long id);
}
```
</details>

## Auditing
`@EnableJpaAuditing` + `@CreatedDate`, `@LastModifiedDate`.
<details>
<summary>Koda bax</summary>

```java
@EntityListeners(AuditingEntityListener.class)
@MappedSuperclass
abstract class BaseEntity {
    @CreatedDate Instant createdAt;
    @LastModifiedDate Instant updatedAt;
}
```
</details>

## Lazy Loading Testdə
Test kontekstində `@DataJpaTest` + `@Transactional` lazy proxy-lər işləməsinə imkan verir.

## Performance Optimallaşdırma
| Mövzu | Strategiya |
|-------|-----------|
| N+1 | Fetch join, batch size (`hibernate.default_batch_fetch_size`) |
| Böyük kolleksiyalar | Pagination / slice |
| Yazma performansı | Batch insert/update (`hibernate.jdbc.batch_size`) |
| Serialization | DTO projection |
| İkinci səviyyə cache | Ehcache / Caffeine / Redis |
| Dirty checking overload | Entity-ləri kiçik saxla |

## 1-ci və 2-ci Səviyyə Cache
| Səviyyə | Əhatə | Qeyd |
|---------|-------|------|
| 1-ci (Persistence Context) | Transaction scope | Default hər zaman aktiv |
| 2-ci | Proses və ya cluster | Ayrı konfiqurasiya tələb |

## Criteria API (Qısa)
<details>
<summary>Koda bax</summary>

```java
public List<Order> dynamicFilter(String status){
    CriteriaBuilder cb = em.getCriteriaBuilder();
    CriteriaQuery<Order> cq = cb.createQuery(Order.class);
    Root<Order> root = cq.from(Order.class);
    List<Predicate> predicates = new ArrayList<>();
    if(status != null){ predicates.add(cb.equal(root.get("status"), status)); }
    cq.where(predicates.toArray(new Predicate[0]));
    return em.createQuery(cq).getResultList();
}
```
</details>

## Tez Sual-Cavab
| Sual | Cavab |
|------|-------|
| Niyə EAGER pis ola bilər? | Lazımsız join/SELECT şişməsi, N+1 risk |
| Entity-ni niyə birbaşa JSON göndərmirik? | Lazy proxy, sonsuz rekursiya, daxili model ifşası |
| Detached entity necə merge olunur? | `entityManager.merge(detached)` |
| @Transactional harada? | Service qatında (controller-də deyil) |
| Version konflikt nə edir? | `OptimisticLockException` atır |

## Ən Yaxşı Təcrübələr
- Həmişə LAZY + konkret fetch join-lərlə ehtiyac qədər data
- DTO projection (xüsusən list endpoint-ləri)
- Entity-lərdə biznes məntiqini minimum saxla (domain model strategiyan varsa istisna)
- Batch yazmalar üçün hibernate.jdbc.batch_size + order_inserts/updates aktiv et
- Sonradan lazım ola bilər deyə EAGER istifadə etmə
- Auditing + @Version default olaraq əlavə et

## Tipik Səhvlər
| Problem | Nəticə |
|---------|--------|
| Controller-də entity istifadə | Döngüsel serialization, daxili model sızması |
| LAZY obyekt transaction xaricində | LazyInitializationException |
| Böyük kolleksiya eager load | Memory / response şişməsi |
| Sorğuya hər sətirdə əlavə select | N+1 performans uçur |

## Növbəti Addım
SQL optimallaşdırması üçün `database/indeksler` sənədinə, `spring/jdbctemplate` ilə low-level nəzarətə və təhlükəsizlik üçün `spring/security` sənədinə bax.

