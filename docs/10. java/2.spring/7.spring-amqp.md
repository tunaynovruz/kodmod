---
title: Spring AMQP (RabbitMQ)
sidebar_label: AMQP
description: Spring AMQP ilə RabbitMQ inteqrasiyası - exchange növləri, queue, routing, ack, retry və dead-letter strategiayaları
slug: spring/amqp
tags: [spring, amqp, rabbitmq, messaging]
keywords: [spring amqp, rabbitmq exchange, rabbitlistener, dead letter, retry, publisher confirms]
hide_table_of_contents: false
---

# Spring AMQP (RabbitMQ)

`Spring AMQP` RabbitMQ ilə messaging işini sadələşdirir: deklarativ queue/exchange binding, `RabbitTemplate`, `@RabbitListener`, retry/dlx və publisher confirm mexanizmləri.

## Əsas Anlayışlar
| Term | İzah |
|------|------|
| Exchange | Mesajları routing qaydasına görə queue-lara yönləndirir |
| Queue | Mesajların saxlandığı struktur |
| Binding | Exchange ilə queue arasındakı əlaqə/qayda |
| Routing Key | Exchange tərəfindən istifadə olunan açar |
| DLX (Dead Letter Exchange) | Emalı uğursuz olan mesajların yönləndirildiyi exchange |
| Prefetch | Consumer-in eyni anda neçə mesajı götürəcəyini müəyyən edir |
| Ack | Mesajın uğurla emal olunduqdan sonra təsdiqlənməsi |
| Nack / Reject | Mesajın qəbul edilməməsi |
| TTL | Mesajın və ya queue-nun ömrü |

## Exchange Növləri
| Növ | Routing Davranışı | İstifadə |
|-----|-------------------|----------|
| direct | Tam uyğun routing key | Punktual yönləndirmə |
| topic | Pattern (a.* , order.#) | Hierarxik / flexible |
| fanout | Hamısına broadcast | Event yayımı |
| headers | Header uyğunluğu | Kənarlaşmış pattern ehtiyacı |

## Maven Asılılıq
<details>
<summary>Koda bax</summary>

```xml
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-amqp</artifactId>
</dependency>
```
</details>

## İnfrastruktur Bean-ləri
<details>
<summary>Koda bax</summary>

```java
@Configuration
public class AmqpConfig {
    public static final String ORDERS_EX = "orders.exchange";
    public static final String ORDERS_Q = "orders.queue";
    public static final String DLX_EX = "orders.dlx";
    public static final String DLX_Q = "orders.dlq";

    @Bean
    DirectExchange ordersExchange(){ return ExchangeBuilder.directExchange(ORDERS_EX).durable(true).build(); }

    @Bean
    DirectExchange deadLetterExchange(){ return ExchangeBuilder.directExchange(DLX_EX).durable(true).build(); }

    @Bean
    Queue ordersQueue(){
        return QueueBuilder.durable(ORDERS_Q)
            .withArgument("x-dead-letter-exchange", DLX_EX)
            .withArgument("x-dead-letter-routing-key", "orders.dlq")
            .withArgument("x-message-ttl", 60000) // 60s
            .build();
    }

    @Bean
    Queue deadLetterQueue(){ return QueueBuilder.durable(DLX_Q).build(); }

    @Bean
    Binding ordersBinding(){
        return BindingBuilder.bind(ordersQueue()).to(ordersExchange()).with("orders.created");
    }

    @Bean
    Binding dlqBinding(){
        return BindingBuilder.bind(deadLetterQueue()).to(deadLetterExchange()).with("orders.dlq");
    }
}
```
</details>

## Mesaj Göndərilməsi (Publisher)
<details>
<summary>Koda bax</summary>

```java
@Service
public class OrderPublisher {
    private final RabbitTemplate template;

    public OrderPublisher(RabbitTemplate template) { this.template = template; }

    public void publish(OrderEvent event){
        template.convertAndSend(AmqpConfig.ORDERS_EX, "orders.created", event);
    }
}
```
</details>

## Consumer (@RabbitListener)
<details>
<summary>Koda bax</summary>

```java
@Component
public class OrderListener {

    @RabbitListener(queues = AmqpConfig.ORDERS_Q)
    public void onMessage(OrderEvent event){
        // İşlə (idempotent ol!)
    }
}
```
</details>

## Manual Ack
<details>
<summary>Koda bax</summary>

```java
@Component
class ManualAckListener {
    @RabbitListener(queues = AmqpConfig.ORDERS_Q, ackMode = "MANUAL")
    public void onMessage(Message message, Channel channel) throws Exception {
        try {
            // Deserialize & process
            channel.basicAck(message.getMessageProperties().getDeliveryTag(), false);
        } catch (Exception ex){
            channel.basicNack(message.getMessageProperties().getDeliveryTag(), false, false); // DLX-ə gedir
        }
    }
}
```
</details>

## Retry Strategiyası
| Yanaşma | İzah |
|---------|------|
| Immediate Retry | Listener tərəfindən kod daxilində döngü tövsiyə edilmir |
| Spring Retry | `@EnableRetry` + `@Retryable` |
| DLX Retry | Gecikmə üçün delayed queue / TTL |

### Spring Retry İnteqrasiyası
<details>
<summary>Koda bax</summary>

```java
@EnableRetry
@Service
class InvoiceProcessor {
    @Retryable(maxAttempts = 3, backoff = @Backoff(delay = 1000, multiplier = 2))
    public void process(Invoice i){ /* uzaq servis çağırışı */ }
}
```
</details>

## Message Converter
| Converter | Məqsəd |
|-----------|--------|
| SimpleMessageConverter | String / Serializable |
| Jackson2JsonMessageConverter | JSON serialize/deser |
| ContentTypeDelegatingMessageConverter | Content-Type əsaslı seçim |

<details>
<summary>Koda bax</summary>

```java
@Bean
public MessageConverter messageConverter(){
    return new Jackson2JsonMessageConverter();
}

@Bean
public RabbitTemplate rabbitTemplate(ConnectionFactory cf, MessageConverter mc){
    RabbitTemplate t = new RabbitTemplate(cf);
    t.setMessageConverter(mc);
    return t;
}
```
</details>

## Publisher Confirms & Returns
Mesaj broker-ə çatdı mı? Exchange routing uğurlu oldu mu?

<details>
<summary>Koda bax</summary>

```java
@Bean
RabbitTemplate confirmTemplate(ConnectionFactory cf){
    RabbitTemplate t = new RabbitTemplate(cf);
    t.setConfirmCallback((corr, ack, cause) -> {
        if(!ack){ /* log failure */ }
    });
    t.setReturnsCallback(returned -> {
        // Queue tapılmadıqda (mandatory=true)
    });
    t.setMandatory(true);
    return t;
}
```
</details>

## Prefetch (Flow Control)
`SimpleRabbitListenerContainerFactory#setPrefetchCount` – çox böyük dəyər memory pressure, çox kiçik throughput azaldır. Başlanğıc üçün 10-50.

## Dead Letter Strategiyası
| Ssenari | Niyə DLX | Həll |
|---------|----------|------|
| Deserializasiya xətası | Mesaj işlənə bilmir | Biznes araşdırma |
| Maks Retry keçildi | Təkrar emal faydasız | Parking lot |
| Biznes qayda blokladı | Gələcəkdə emal deyil | Arxiv |

## Idempotent Emal
- Unikal biznes açar (orderId) ilə processed table
- Ya da Redis SET: `SADD processed:orderIds <id>`

## Performans Təklifləri
| Mövzu | Yanaşma |
|-------|---------|
| Throughput | Prefetch artır, consumer concurrency |
| Latency | JSON ölçüsünü kiçilt, serializer optimallaşdır |
| Reliability | Persistent mesaj + durable queue |
| Backpressure | Prefetch azalt, publish sürətini ölç |

## Security
- TLS aktiv et (amqps)
- User-lərə minimal permission (configure, read, write)
- Management UI üçün ayrıca user

## Monitoring Metrikləri
- Queue depth (mesaj sayı)
- Consumer lag (mesajların gözləmə vaxtı)
- Reject / DLX rate
- Retry count
- Processing time p95/p99

## Tez Sual-Cavab
| Sual | Cavab |
|------|-------|
| Mesaj niyə itmir? | Durable exchange+queue + persistent message |
| Ordering zəmanəti? | Queue daxilində FIFO (prefetch>1 + parallel emalda diqqət) |
| Niyə nack requeue=false? | Retry fırlanma (poison message) riskini kəsmək |
| Delay necə? | TTL + dead-letter və ya Delayed Message Plugin |

## Ən Yaxşı Təcrübələr
- Poison message üçün DLX zorunludur
- Idempotent consumer yaz (at-least-once model)
- Schema dəyişikliklərini versiyala
- Monitoring olmadan prod-a çıxma
- Connection reuse üçün connection factory paylaş

## Növbəti Addım
Access control və API qorunması üçün: `spring/security` sənədinə keç.

