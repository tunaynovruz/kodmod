---
title: Spring Kafka
sidebar_label: Kafka
description: Spring Kafka ilə producer, consumer, listener container, serialization, error handling və idempotentlik
slug: spring/kafka
tags: [spring, kafka, messaging, event-driven]
keywords: [spring kafka, kafka listener, producerfactory, consumerfactory, error handler, retry, dlq]
hide_table_of_contents: false
---

# Spring Kafka

`Spring for Apache Kafka` Kafka ilə inteqrasiyanı sadələşdirir: `KafkaTemplate`, `@KafkaListener`, error/retry mexanizmləri, batch processing və header idarəetməsi kimi imkanlar verir.

## Əsas Anlayışlar
| Anlayış | İzah |
|--------|------|
| Topic | Mesajların kateqoriya ilə loji qruplaşması |
| Partition | Paralel emal üçün bölmə (ordering yalnız partition daxilində) |
| Offset | Partition daxilində ardıcıllıq nömrəsi |
| Consumer Group | Eyni qrupda partition-lar bölüşdürülür |
| Rebalance | Consumer qrup dəyişikliyi zamanı partition yenidən paylanması |
| Key | Partition seçimi üçün (hash(key) % partitionCount) |
| Header | Mesaj metadata |

## Konfiqurasiya (Producer + Consumer)
<details>
<summary>Koda bax</summary>

```java
@Configuration
@EnableKafka
public class KafkaConfig {

    @Bean
    public ProducerFactory<String, OrderEvent> producerFactory() {
        Map<String, Object> props = new HashMap<>();
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        props.put(ProducerConfig.ACKS_CONFIG, "all"); // Güclü durability
        props.put(ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG, true); // Idempotent producer
        return new DefaultKafkaProducerFactory<>(props);
    }

    @Bean
    public KafkaTemplate<String, OrderEvent> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }

    @Bean
    public ConsumerFactory<String, OrderEvent> consumerFactory() {
        Map<String, Object> props = new HashMap<>();
        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");
        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);
        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);
        props.put(JsonDeserializer.TRUSTED_PACKAGES, "*");
        props.put(ConsumerConfig.GROUP_ID_CONFIG, "order-consumers");
        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false); // Manual commit
        return new DefaultKafkaConsumerFactory<>(props, new StringDeserializer(),
            new JsonDeserializer<>(OrderEvent.class));
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, OrderEvent> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, OrderEvent> factory =
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        factory.setConcurrency(3); // 3 paralel thread
        factory.getContainerProperties().setAckMode(ContainerProperties.AckMode.MANUAL);
        return factory;
    }
}
```
</details>

## Mesaj Göndərilməsi
<details>
<summary>Koda bax</summary>

```java
@Service
public class OrderEventPublisher {
    private final KafkaTemplate<String, OrderEvent> template;

    public OrderEventPublisher(KafkaTemplate<String, OrderEvent> template) {
        this.template = template;
    }

    public void publish(OrderEvent event) {
        template.send("orders", event.orderId().toString(), event)
            .whenComplete((result, ex) -> {
                if (ex != null) {
                    // log / metric
                }
            });
    }
}
```
</details>

## Consumer (@KafkaListener)
<details>
<summary>Koda bax</summary>

```java
@Component
public class OrderEventListener {

    @KafkaListener(topics = "orders", groupId = "order-consumers")
    public void handle(OrderEvent event) {
        // Process event
    }
}
```
</details>

### Manual Offset Commit
<details>
<summary>Koda bax</summary>

```java
@Component
class OrderAckListener {
    @KafkaListener(topics = "orders", containerFactory = "kafkaListenerContainerFactory")
    public void onMessage(OrderEvent event, Acknowledgment ack) {
        try {
            // İşlə
            ack.acknowledge(); // Uğurlu olduqda offset commit
        } catch (Exception ex) {
            // Retry və ya DLQ strategiyası
        }
    }
}
```
</details>

## Batch Processing
<details>
<summary>Koda bax</summary>

```java
@Bean
ConcurrentKafkaListenerContainerFactory<String, OrderEvent> batchFactory(ConsumerFactory<String, OrderEvent> cf){
    var f = new ConcurrentKafkaListenerContainerFactory<String, OrderEvent>();
    f.setConsumerFactory(cf);
    f.setBatchListener(true);
    return f;
}

@KafkaListener(topics = "orders", containerFactory = "batchFactory")
public void batch(List<OrderEvent> events){
    // Bütün batch birlikdə işlənə bilər (DB bulk insert)
}
```
</details>

## Header-lər və Metadata
<details>
<summary>Koda bax</summary>

```java
@KafkaListener(topics = "orders")
public void listen(@Header(KafkaHeaders.RECEIVED_KEY) String key,
                   @Header(KafkaHeaders.OFFSET) long offset,
                   OrderEvent payload) {
    // Audit / tracing
}
```
</details>

## Error Handling Strategiyaları
| Strategiya | İzah |
|-----------|------|
| Retry (in-memory) | Kiçik transient xətalar üçün |
| Backoff policy | Interval artımı ilə retry |
| DLQ (Dead Letter Topic) | Təkrar-işlənməsi mümkün olmayan mesajlar |
| Parking Lot | Ayrı topic-ə qoyub manual araşdırma |

### Default Error Handler (Spring Kafka 2.8+)
<details>
<summary>Koda bax</summary>

```java
@Bean
public DefaultErrorHandler errorHandler(){
    FixedBackOff backOff = new FixedBackOff(2000L, 3); // 3 retry
    DefaultErrorHandler handler = new DefaultErrorHandler((record, ex) -> {
        // DLQ-yə yönləndirə bilərik
    }, backOff);
    handler.addNotRetryableExceptions(IllegalArgumentException.class);
    return handler;
}
```
</details>

## Idempotent Emal
- Producer: `enable.idempotence=true`
- Consumer: işlənmiş event-lərin `eventId`-ni store edib yenidən prosesi blokla
- Outbox Pattern: DB transaction + outbox table + separate publisher

## Serialization
| Format | Üstünlük | Qeyd |
|--------|----------|------|
| JSON | Oxunaqlı | Daha böyük ölçü |
| Avro | Schema evolution | Schema Registry tələb |
| Protobuf | Sıx və sürətli | IDL lazımdır |

## Performance Parametrləri
| Parametr | Tuning |
|----------|--------|
| linger.ms | Kiçik dəyərlər latency, böyük throughput |
| batch.size | Mesajları paketləyir |
| compression.type | gzip / lz4 / snappy |
| fetch.min.bytes | Consumer üçün paketləmə |

## Monitoring Metrikləri
- Lag (current offset vs end offset)
- Error rate
- Processing latency
- Retry count
- Dead letter count

## Tez Sual-Cavab
| Sual | Cavab |
|------|-------|
| Ordering necə qorunur? | Yalnız eyni partition daxilində |
| Niyə manual commit? | At-least-once + nəzarət |
| Exactly-once mümkündür? | Kafka Streams + transactional producer |
| Rebalance nə vaxt olur? | Consumer qoşulanda/çıxanda və ya subscription dəyişəndə |

## Ən Yaxşı Təcrübələr
- Schema evolution üçün Avro + Registry
- Idempotent consumer (təmiz retry dəstək üçün)
- DLQ strategiyası əvvəlcədən müəyyən et
- Backpressure: batch processing + sürət ölçümü
- Observability: tracing (traceId header)

## Növbəti Addım
Messaj yönləndirmə və routing tipləri üçün: `spring/amqp` sənədinə bax.

