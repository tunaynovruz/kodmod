---
title: Spring Security
sidebar_label: Security
description: Spring Security ilə Authentication, Authorization, Filter Chain, JWT, Method Security, CSRF və best practices
slug: spring/security
tags: [spring, security, auth, jwt, oauth2]
keywords: [spring security, authentication, authorization, jwt, method security, csrf, password encoder]
hide_table_of_contents: false
---

# Spring Security

Spring Security JVM ekosistemində ən geniş istifadə olunan təhlükəsizlik framework-üdür. Authentication (kimlik təsdiqləmə) və Authorization (icazə yoxlama) üçün pluggable arxitektura, standart HTTP security, method-level qoruma, JWT/OAuth2 inteqrasiyası və enterprise səviyyəsində genişlənə bilən model təqdim edir.

## Əsas Anlayışlar
| Termin | İzah |
|--------|------|
| SecurityFilterChain | HTTP request-lərin keçdiyi filter ardıcıllığı |
| Authentication | İstifadəçi və ya client-in kimliyi haqqında məlumat obyekt |
| Principal | Kimliyi təmsil edən obyekt (adətən UserDetails) |
| GrantedAuthority | ROLE_ və ya permission əsaslı icazə dəyərləri |
| SecurityContext | Cari thread üçün Authentication saxlanılır |
| UserDetailsService | İstifadəçi məlumatını yükləyən servis |
| PasswordEncoder | Parol hashing/verify funksiyası |
| Method Security | @PreAuthorize, @PostAuthorize ilə metod səviyyəsində icazə |
| CSRF | Cross-Site Request Forgery qorunması |
| CORS | Cross-Origin Resource Sharing icazə qaydaları |

## Filter Chain Axını
1. Request daxil olur
2. Security filter-lər (UsernamePasswordAuthenticationFilter, JwtCustomFilter və s.)
3. Authentication uğurlu -> SecurityContext doldurulur
4. Authorization qərarı (AccessDecisionManager)
5. Controller / Handler icra
6. Clear SecurityContext (ThreadLocal təmizlənir)

## Minimal Konfiqurasiya (SecurityFilterChain)
<details>
<summary>Koda bax</summary>

```java
@Configuration
@EnableMethodSecurity // @PreAuthorize üçün
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // REST token-based üçün
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/actuator/health", "/public/**").permitAll()
                .requestMatchers(HttpMethod.POST, "/api/v1/users").hasRole("ADMIN")
                .anyRequest().authenticated()
            )
            .httpBasic(Customizer.withDefaults())
            .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder(){
        return new BCryptPasswordEncoder();
    }

    @Bean
    public UserDetailsService userDetailsService(PasswordEncoder encoder){
        UserDetails admin = User.builder()
            .username("admin")
            .password(encoder.encode("ChangeMe123!"))
            .roles("ADMIN")
            .build();
        return new InMemoryUserDetailsManager(admin);
    }
}
```
</details>

## Custom UserDetailsService (DB ilə)
<details>
<summary>Koda bax</summary>

```java
@Service
class JpaUserDetailsService implements UserDetailsService {
    private final UserRepository repo;
    private final PasswordEncoder encoder;

    JpaUserDetailsService(UserRepository repo, PasswordEncoder encoder){
        this.repo = repo; this.encoder = encoder;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        AppUser user = repo.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User tapılmadı"));
        return User.withUsername(user.username())
            .password(user.passwordHash())
            .authorities(user.roles().stream().map(r -> "ROLE_" + r).toArray(String[]::new))
            .accountLocked(!user.active())
            .build();
    }
}
```
</details>

## Password Encoding
| Encoder | Üstünlük | Qeyd |
|---------|----------|------|
| BCrypt | Adaptive, geniş istifadə | Default tövsiyə |
| Argon2 | Daha modern | Native dependence |
| PBKDF2 | Standart | Əl ilə parametr tənzimləmə |

Heç vaxt parolu plain-text saxlamayın / log etməyin.

## JWT Inteqrasiyası (Custom Filter)
<details>
<summary>Koda bax</summary>

```java
@Component
class JwtAuthFilter extends OncePerRequestFilter {
    private final JwtService jwt;
    private final UserDetailsService uds;

    JwtAuthFilter(JwtService jwt, UserDetailsService uds){
        this.jwt = jwt; this.uds = uds;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
        throws ServletException, IOException {
        String header = request.getHeader("Authorization");
        if(header != null && header.startsWith("Bearer ")){
            String token = header.substring(7);
            String username = jwt.extractUsername(token);
            if(username != null && SecurityContextHolder.getContext().getAuthentication() == null){
                UserDetails user = uds.loadUserByUsername(username);
                if(jwt.isValid(token, user)){
                    UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(
                        user, null, user.getAuthorities());
                    auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                    SecurityContextHolder.getContext().setAuthentication(auth);
                }
            }
        }
        chain.doFilter(request, response);
    }
}
```
</details>

### Filter-i Chain-ə Əlavə Etmə
<details>
<summary>Koda bax</summary>

```java
@Bean
SecurityFilterChain jwtChain(HttpSecurity http, JwtAuthFilter jwtFilter) throws Exception {
    http
        .csrf(cs -> cs.disable())
        .sessionManagement(sm -> sm.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
        .authorizeHttpRequests(a -> a.anyRequest().authenticated())
        .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);
    return http.build();
}
```
</details>

## Method Security
| Annotasiya | İzah |
|------------|------|
| `@PreAuthorize` | Metod icrasından əvvəl SpEL qiymətləndirmə |
| `@PostAuthorize` | Metod nəticəsindən sonra şərt |
| `@PostFilter` | Collection nəticələri filter |
| `@Secured` | Sadə ROLE yoxlaması |

<details>
<summary>Koda bax</summary>

```java
@Service
class AccountService {
    @PreAuthorize("hasRole('ADMIN') or #id == authentication.principal.username")
    public AccountDto getAccount(String id){ /* ... */ return null; }

    @PreAuthorize("hasAuthority('SCOPE_payments.write')")
    public void createPayment(PaymentRequest req){ /* ... */ }
}
```
</details>

## Authorization Modelləri
| Model | İzah | Nümunə |
|-------|------|--------|
| RBAC | Role-Based Access Control | ROLE_ADMIN, ROLE_USER |
| ABAC | Attribute-Based (SpEL + obyekt attribute) | @PreAuthorize("#doc.owner == authentication.name") |
| ACL | Object-level icazələr | Mürəkkəb resurs paylaşımı |

## Exception Handling
| Mexanizm | İzah |
|----------|------|
| AuthenticationEntryPoint | Auth tələb olunan resursda anonymous user |
| AccessDeniedHandler | Auth var, lakin icazə yoxdur |

<details>
<summary>Koda bax</summary>

```java
@Bean
SecurityFilterChain customHandlers(HttpSecurity http) throws Exception {
    http
      .exceptionHandling(ex -> ex
          .authenticationEntryPoint((req,res,e) -> res.sendError(401, "Auth lazımdır"))
          .accessDeniedHandler((req,res,e) -> res.sendError(403, "İcazə yoxdur"))
      );
    return http.build();
}
```
</details>

## CSRF
- Stateless REST API (JWT) -> çox vaxt deaktiv (`csrf.disable()`)
- Browser form login -> aktiv saxla
- Token form field: `_csrf`

## CORS
<details>
<summary>Koda bax</summary>

```java
@Bean
CorsConfigurationSource corsSource(){
    CorsConfiguration c = new CorsConfiguration();
    c.setAllowedOrigins(List.of("https://app.example.com"));
    c.setAllowedMethods(List.of("GET","POST","PUT","DELETE"));
    c.setAllowedHeaders(List.of("Authorization","Content-Type"));
    UrlBasedCorsConfigurationSource s = new UrlBasedCorsConfigurationSource();
    s.registerCorsConfiguration("/**", c);
    return s;
}
```
</details>

## Security Headers
| Header | Funksiya |
|--------|----------|
| X-Content-Type-Options | MIME sniffing blok |
| X-Frame-Options | Clickjacking qorunması |
| Content-Security-Policy (CSP) | Script/style mənbə məhdudiyyəti |
| Strict-Transport-Security | HTTPS məcburiyyəti |
| Referrer-Policy | Referrer məlumat məhdudiyyəti |

## Logging & Audit
- Login uğur / uğursuz hadisələri
- Privileged action-lar (silinmə, rol dəyişikliyi)
- JWT invalid/expired hadisələri
- Suspicious IP pattern-lər

## Test
<details>
<summary>Koda bax</summary>

```java
@WebMvcTest(controllers = UserController.class)
class UserControllerSecurityTest {
    @Autowired MockMvc mvc;

    @Test
    @WithMockUser(username = "admin", roles = {"ADMIN"})
    void adminAccess() throws Exception {
        mvc.perform(get("/api/v1/users/1"))
            .andExpect(status().isOk());
    }

    @Test
    void anonymousForbidden() throws Exception {
        mvc.perform(get("/api/v1/users/1"))
            .andExpect(status().isUnauthorized());
    }
}
```
</details>

## Tez Sual-Cavab
| Sual | Cavab |
|------|-------|
| Niyə `ROLE_` prefiksi var? | Standart GrantedAuthority konvensiyası |
| JWT harada saxlanmalı? | HTTP header (Authorization: Bearer) |
| Refresh token necə? | Ayrı endpoint + uzunömürlü secure storage (httpOnly cookie) |
| Parolu nə vaxt yeniləmək? | Şübhəli fəaliyyət / müddət bitmə siyasəti |

## Ən Yaxşı Təcrübələr
- Parollar: BCrypt (strength >=10)
- Stateless API-lərdə session storage istifadə etmə
- Minimal lazım olan authority ver (principle of least privilege)
- Security test-ləri pipeline-da məcbur et
- Reusable claim-lərlə JWT ölçüsünü aşma
- Logout: refresh token invalidation + short access token TTL
- Sensitive header-ləri log etmə

## Tipik Səhvlər
| Problem | Nəticə |
|---------|--------|
| CSRF tam deaktiv + cookie-based auth | CSRF hücumu imkanı |
| Hər şeyi `permitAll()` | Qorumalı endpoint açılır |
| Password hashing yox | İtki halında kütləvi kompromis |
| Long-lived access token | Oğurluq halında risk uzun müddət |

## Növbəti Addım
Təhlükəsizlik mövzularını genişləndirmək üçün `security/csp`, `security/csrf`, `security/xss` sənədlərinə bax və daha dərinə get: OAuth2, Keycloak inteqrasiyası, mərkəzləşdirilmiş token introspection.
