---
title: Java Future və CompletableFuture
description: Java-da Future və CompletableFuture ilə asynchronous programming
slug: futures
tags: [java, concurrency, future, completablefuture, async]
keywords: [java future, completablefuture, asynchronous programming, concurrent]
hide_table_of_contents: false
sidebar_label: Future
---

# Java Future və CompletableFuture

## Future Nədir?

Future asynchronous əməliyyatların nəticəsini təmsil edir. Əməliyyat tamamlanmamış ola bilər və nəticə gələcəkdə əldə ediləcək.

## Future Interface

### Basic Usage
```java
ExecutorService executor = Executors.newFixedThreadPool(2);

Future<String> future = executor.submit(() -> {
    Thread.sleep(2000);
    return "Hello from Future!";
});

// Nəticəni əldə et (blocking)
String result = future.get(); // 2 saniyə gözləyəcək
System.out.println(result);

executor.shutdown();
```

### Future Metodları
```java
Future<Integer> future = executor.submit(() -> {
    Thread.sleep(3000);
    return 42;
});

// Status yoxlama
boolean isDone = future.isDone();           // false (əvvəlcə)
boolean isCancelled = future.isCancelled(); // false

// Timeout ilə
try {
    Integer result = future.get(1, TimeUnit.SECONDS); // TimeoutException
} catch (TimeoutException e) {
    System.out.println("Timeout!");
}

// Cancel etmək
boolean cancelled = future.cancel(true); // true = interrupt if running
```

## CompletableFuture

Java 8-də təqdim edilmiş, daha güclü Future implementasiyası.

### Simple Usage
```java
// Async task yaratmaq
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        return "Error";
    }
    return "Hello CompletableFuture!";
});

// Nəticəni işləmək (non-blocking)
future.thenAccept(System.out::println);

// Blocking get
String result = future.get();
```

## Chaining Operations

### thenApply() - Transform
```java
CompletableFuture<Integer> future = CompletableFuture
    .supplyAsync(() -> "42")
    .thenApply(Integer::parseInt)
    .thenApply(n -> n * 2);

future.thenAccept(System.out::println); // 84
```

### thenCombine() - Combine Two Futures
```java
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "World");

CompletableFuture<String> combined = future1.thenCombine(future2, 
    (s1, s2) -> s1 + " " + s2);

combined.thenAccept(System.out::println); // Hello World
```

## Error Handling

### handle() - Handle Both Result and Exception
```java
CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> {
        if (Math.random() > 0.5) {
            throw new RuntimeException("Random error!");
        }
        return "Success";
    })
    .handle((result, ex) -> {
        if (ex != null) {
            return "Error: " + ex.getMessage();
        }
        return result;
    });
```

### exceptionally() - Handle Only Exceptions
```java
CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> {
        throw new RuntimeException("Error occurred");
    })
    .exceptionally(ex -> "Default value");

future.thenAccept(System.out::println); // Default value
```

## Combining Multiple Futures

### allOf() - Wait for All
```java
CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> "Task 1");
CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> "Task 2");
CompletableFuture<String> f3 = CompletableFuture.supplyAsync(() -> "Task 3");

CompletableFuture<Void> allFutures = CompletableFuture.allOf(f1, f2, f3);

allFutures.thenRun(() -> {
    try {
        System.out.println(f1.get());
        System.out.println(f2.get());
        System.out.println(f3.get());
    } catch (Exception e) {
        e.printStackTrace();
    }
});
```

### anyOf() - First to Complete
```java
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(2000); } catch (InterruptedException e) {}
    return "Slow task";
});

CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(1000); } catch (InterruptedException e) {}
    return "Fast task";
});

CompletableFuture<Object> firstCompleted = CompletableFuture.anyOf(future1, future2);
firstCompleted.thenAccept(System.out::println); // Fast task
```

## Practical Examples

### Parallel Processing
```java
public CompletableFuture<String> fetchUserData(int userId) {
    return CompletableFuture.supplyAsync(() -> {
        // Simulate HTTP call
        try { Thread.sleep(1000); } catch (InterruptedException e) {}
        return "User data for ID: " + userId;
    });
}

public CompletableFuture<String> fetchUserPosts(int userId) {
    return CompletableFuture.supplyAsync(() -> {
        try { Thread.sleep(800); } catch (InterruptedException e) {}
        return "Posts for user: " + userId;
    });
}

// Parallel fetch
CompletableFuture<String> userData = fetchUserData(123);
CompletableFuture<String> userPosts = fetchUserPosts(123);

CompletableFuture<String> combined = userData.thenCombine(userPosts,
    (data, posts) -> data + "\n" + posts);
```

## Best Practices

1. **Non-blocking operations istifadə edin:**
   ```java
   // Blocking (pis)
   String result = future.get();
   
   // Non-blocking (yaxşı)
   future.thenAccept(System.out::println);
   ```

2. **Error handling unutmayın:**
   ```java
   future
       .thenApply(this::process)
       .exceptionally(ex -> "Default value");
   ```

3. **Custom executor istifadə edin:**
   ```java
   ExecutorService executor = Executors.newFixedThreadPool(4);
   CompletableFuture.supplyAsync(task, executor);
   ```

4. **join() vs get():**
   ```java
   // join() - unchecked exception
   String result = future.join();
   
   // get() - checked exception (try-catch lazım)
   String result = future.get();
   ```

5. **Timeout with Default:**
   ```java
   CompletableFuture<String> future = CompletableFuture
       .supplyAsync(() -> slowOperation())
       .completeOnTimeout("Default", 2, TimeUnit.SECONDS);
   ```

## Common Patterns

### Sequential vs Parallel
```java
// Sequential (3 saniyə)
String result1 = task1(); // 1 saniyə
String result2 = task2(); // 1 saniyə  
String result3 = task3(); // 1 saniyə

// Parallel (1 saniyə)
CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> task1());
CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> task2());
CompletableFuture<String> f3 = CompletableFuture.supplyAsync(() -> task3());

CompletableFuture.allOf(f1, f2, f3).join();
```

### Pipeline Processing
```java
CompletableFuture<String> pipeline = CompletableFuture
    .supplyAsync(() -> "input")
    .thenApply(this::step1)
    .thenApply(this::step2)
    .thenApply(this::step3)
    .exceptionally(ex -> "Error: " + ex.getMessage());
```

### Conditional Processing
```java
CompletableFuture<String> result = CompletableFuture
    .supplyAsync(() -> getData())
    .thenCompose(data -> {
        if (data.isEmpty()) {
            return CompletableFuture.completedFuture("No data");
        }
        return CompletableFuture.supplyAsync(() -> processData(data));
    });
```

## Üstünlükləri

- **Non-blocking** - Thread-ləri blok etmir
- **Composable** - Əməliyyatları birləşdirmək asan
- **Error handling** - Exception-ları idarə etmək asan
- **Performance** - Parallel işləmə imkanı
- **Readable** - Kod oxunaqlıdır